<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Write Once,Run Anywhere"><meta name="keywords" content="Java,并发,JVM,Spring,Spring Boot,源码,架构"><title>Java基础18：多线程 | Joe's Blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java基础18：多线程</h1><a id="logo" href="/.">Joe's Blog</a><p class="description">Learning Java</p></div><div id="nav-menu"> <a href="/." class="current"><i class="fa fa-home">首页</i></a> <a href="/archives/"><i class="fa fa-archive">归档</i></a> <a href="/about/"><i class="fa fa-user">关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java基础18：多线程</h1><div class="post-meta"><a href="/2018/11/18/Java基础18：多线程/#comments" class="comment-count"></a><p><span class="date">Nov 18, 2018</span><span><a href="/categories/Java基础/" class="category">Java基础</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1. 多线程"></a>1. 多线程</h1><blockquote><p>线程是一个独立执行的调用序列，同一个进程的线程在同一时刻共享一些系统资源（比如文件句柄等）也能访问同一个进程所创建的对象资源（内存资源）。java.lang.Thread对象负责统计和控制这种行为。</p><p>每个程序都至少拥有一个线程-<strong>即作为Java虚拟机(JVM)启动参数运行在主类main方法的线程。</strong>在Java虚拟机初始化过程中也可能启动其他的后台线程。这种线程的数目和种类因JVM的实现而异。然而所有用户级线程都是显式被构造并在主线程或者是其他用户线程中被启动。</p></blockquote><p>为什么要使用多线程</p><blockquote><p>发挥多核处理器的能力</p></blockquote><p>如果只使用单线程，无法使用到全部的CPU资源，造成CPU资源的浪费。</p><blockquote><p>获得更高的吞吐率</p></blockquote><p>如果程序是单核的，等待I/O时，处理器将处于空闲状态</p><blockquote><p>更好的编程模型</p></blockquote><p><img src="http://incdn1.b0.upaiyun.com/2017/10/0daf3c6197b0a14eef74a013a154024a.png" alt="Java线程内存模型"></p><p><img src="http://incdn1.b0.upaiyun.com/2017/10/3d9d0af74829fa666dc137ef89a7b332.png" alt=""></p><h1 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h1><ul><li>NEW</li><li>RUNNABLE</li><li>WAITING</li><li>TIME_WAITING</li><li>BLOCKED</li><li>TERMINATED</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1689841-383f7101e6588094.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="线程状态"></p><h1 id="3-创建线程"><a href="#3-创建线程" class="headerlink" title="3. 创建线程"></a>3. 创建线程</h1><ul><li>继承Thread</li><li>实现Runnable</li><li>实现Callable(带返回值)</li><li>从线程池获取</li></ul><blockquote><p>继承Thread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" i"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span> i</span><br><span class="line">Thread-<span class="number">0</span> i</span><br><span class="line">Thread-<span class="number">1</span> i</span><br><span class="line">Thread-<span class="number">0</span> i</span><br><span class="line">Thread-<span class="number">0</span> i</span><br><span class="line">Thread-<span class="number">1</span> i</span><br></pre></td></tr></table></figure><blockquote><p>实现Runnable</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//.......省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread()).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现Callable(带返回值)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Callable对象</span></span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建FutureTask对象接收返回值</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(ft.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyThread对象，同时作为了Thread对象的target。</p><blockquote><p>线程池获取线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//每个线程对sum自增5次</span></span><br><span class="line">            executorService.execute(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    sum += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="4-启动线程"><a href="#4-启动线程" class="headerlink" title="4. 启动线程"></a>4. 启动线程</h1><p>要想实现多线程，需要重写<code>run</code>方法，并使用<code>start</code>方法启动线程。</p><p><strong>当线程终止之后，是不能被重新启动的。在同一个Thread上调用多次start方法会抛出InvalidThreadStateException异常。</strong></p><p>判断线程是否存活：<code>isAlive</code>方法</p><p>线程优先级：<code>setPriority</code>， <code>getPriority</code>方法</p><h1 id="5-线程中断"><a href="#5-线程中断" class="headerlink" title="5. 线程中断"></a>5. 线程中断</h1><blockquote><p>每个线程都有一个相关的Boolean类型的中断标识。<strong>在线程t上调用t.interrupt会将该线程的中断标识设为true</strong>，除非线程t正处于Object.wait,Thread.sleep,或者Thread.join,这些情况下interrupt调用会导致t上的这些操作抛出InterruptedException异常，但是t的中断标识会被设为false。</p></blockquote><blockquote><p><strong>任何一个线程的中断状态都可以通过调用isInterrupted方法来得到。如果线程已经通过interrupt方法被中断，这个方法将会返回true。</strong></p></blockquote><blockquote><p>但是如果调用了Thread.interrupted方法且中断标识还没有被重置，或者是线程处于wait，sleep，join过程中，调用isInterrupted方法将会抛出InterruptedException异常。</p></blockquote><blockquote><p>调用t.join()方法将会暂停执行调用线程，直到线程t执行完毕：当t.isAlive()方法返回false的时候调用t.join()将会直接返回(return)。</p></blockquote><blockquote><p>另一个带参数毫秒(millisecond)的join方法在被调用时，如果线程没能够在指定的时间内完成，调用线程将重新得到控制权。</p></blockquote><blockquote><p>因为isAlive方法的实现原理，所以在一个还没有启动的线程上调用join方法是没有任何意义的。同样的，试图在一个还没有创建的线程上调用join方法也是不明智的。</p></blockquote><blockquote><p>起初，Thread类还支持一些另外一些控制方法：suspend,resume,stop以及destroy。这几个方法已经被声明过期。其中destroy方法从来没有被实现，估计以后也不会。而通过使用等待/唤醒机制增加suspend和resume方法在安全性和可靠性的效果有所欠缺</p></blockquote><p><strong>Thread的静态方法</strong></p><blockquote><p>静态方法<br>Thread类中的部分方法被设计为只适用于当前正在运行的线程（即调用Thread方法的线程）。为强调这点，这些方法都被声明为静态的。</p></blockquote><blockquote><p>Thread.currentThread方法会返回当前线程的引用，得到这个引用可以用来调用其他的非静态方法，比如Thread.currentThread().getPriority()会返回调用线程的优先级。</p></blockquote><blockquote><p>Thread.interrupted方法会清除当前线程的中断状态并返回前一个状态。（一个线程的中断状态是不允许被其他线程清除的）</p></blockquote><blockquote><p>Thread.sleep(long msecs)方法会使得当前线程暂停执行至少msecs毫秒。</p></blockquote><blockquote><p>Thread.yield方法纯粹只是建议Java虚拟机对其他已经处于就绪状态的线程（如果有的话）调度执行，而不是当前线程。最终Java虚拟机如何去实现这种行为就完全看其喜好了。</p></blockquote><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">每一个线程都是一个线程组中的成员。默认情况下，新建线程和创建它的线程属于同一个线程组。线程组是以树状分布的。</span><br><span class="line"></span><br><span class="line">当创建一个新的线程组，这个线程组成为当前线程组的子组。getThreadGroup方法会返回当前线程所属的线程组，对应地，ThreadGroup类也有方法可以得到哪些线程目前属于这个线程组，比如enumerate方法。</span><br><span class="line"></span><br><span class="line">ThreadGroup类存在的一个目的是支持安全策略来动态的限制对该组的线程操作。比如对不属于同一组的线程调用interrupt是不合法的。</span><br><span class="line"></span><br><span class="line">这是为避免某些问题(比如，一个applet线程尝试杀掉主屏幕的刷新线程)所采取的措施。ThreadGroup也可以为该组所有线程设置一个最大的线程优先级。</span><br><span class="line"></span><br><span class="line">线程组往往不会直接在程序中被使用。在大多数的应用中，如果仅仅是为在程序中跟踪线程对象的分组，那么普通的集合类（比如java.util.Vector）应是更好的选择。</span><br></pre></td></tr></table></figure><h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public class 多线程实例 &#123;</span><br><span class="line"></span><br><span class="line">    //继承thread</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        class A extends Thread &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;A run&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A a = new A();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现Runnable</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        class B implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;B run&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        B b = new B();</span><br><span class="line">        //Runable实现类需要由Thread类包装后才能执行</span><br><span class="line">        new Thread(b).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //有返回值的线程</span><br><span class="line">    @Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        Callable callable = new Callable() &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            @Override</span><br><span class="line">            public Object call() throws Exception &#123;</span><br><span class="line">                for (int i = 0;i &lt; 5;i ++) &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //这里要用FutureTask，否则不能加入Thread构造方法</span><br><span class="line">        FutureTask futureTask = new FutureTask(callable);</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //线程池实现</span><br><span class="line">    @Test</span><br><span class="line">    public void test4() &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line">        //execute直接执行线程</span><br><span class="line">        executorService.execute(new Thread());</span><br><span class="line">        executorService.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;runnable&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //submit提交有返回结果的任务，运行完后返回结果。</span><br><span class="line">        Future future = executorService.submit(new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                return &quot;a&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        //有返回值的线程组将返回值存进集合</span><br><span class="line">        for (int i = 0;i &lt; 5;i ++ ) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            Future future1 = executorService.submit(new Callable&lt;String&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String call() throws Exception &#123;</span><br><span class="line">                    return &quot;res&quot; + finalI;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            try &#123;</span><br><span class="line">                list.add((String) future1.get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">public class 线程的状态转换 &#123;</span><br><span class="line">//一开始线程是init状态，结束时是terminated状态</span><br><span class="line">class t implements Runnable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public t(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(name + &quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试join，父线程在子线程运行时进入waiting状态</span><br><span class="line">@Test</span><br><span class="line">public void test1() throws InterruptedException &#123;</span><br><span class="line">    Thread dad = new Thread(new Runnable() &#123;</span><br><span class="line">        Thread son = new Thread(new t(&quot;son&quot;));</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;dad init&quot;);</span><br><span class="line">            son.start();</span><br><span class="line">            try &#123;</span><br><span class="line">                //保证子线程运行完再运行父线程</span><br><span class="line">                son.join();</span><br><span class="line">                System.out.println(&quot;dad run&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //调用start，线程进入runnable状态，等待系统调度</span><br><span class="line">    dad.start();</span><br><span class="line">    //在父线程中对子线程实例使用join，保证子线程在父线程之前执行完</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试sleep</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;t1 run&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //主线程休眠。进入time waiting状态</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程2进入blocked状态。</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    test4();</span><br><span class="line">    Thread.yield();//进入runnable状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试blocked状态</span><br><span class="line">public static void test4() &#123;</span><br><span class="line">    class A &#123;</span><br><span class="line">        //线程1获得实例锁以后线程2无法获得实例锁，所以进入blocked状态</span><br><span class="line">        synchronized void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                System.out.println(&quot;run&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A a = new A();</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;t1 get lock&quot;);</span><br><span class="line">            a.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;t2 get lock&quot;);</span><br><span class="line">            a.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//volatile保证线程可见性</span><br><span class="line">volatile static int flag = 1;</span><br><span class="line">//object作为锁对象，用于线程使用wait和notify方法</span><br><span class="line">volatile static Object o = new Object();</span><br><span class="line">//测试wait和notify</span><br><span class="line">//wait后进入waiting状态，被notify进入blocked（阻塞等待锁释放）或者runnable状态（获取到锁）</span><br><span class="line">public void test5() &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //wait和notify只能在同步代码块内使用</span><br><span class="line">            synchronized (o) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (flag == 0) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(2000);</span><br><span class="line">                            System.out.println(&quot;thread1 wait&quot;);</span><br><span class="line">                            //释放锁，线程挂起进入object的等待队列，后续代码运行</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;thread1 run&quot;);</span><br><span class="line">                    System.out.println(&quot;notify t2&quot;);</span><br><span class="line">                    flag = 0;</span><br><span class="line">                    //通知等待队列的一个线程获取锁</span><br><span class="line">                    o.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    //解释同上</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (o) &#123;</span><br><span class="line">                    if (flag == 1) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(2000);</span><br><span class="line">                            System.out.println(&quot;thread2 wait&quot;);</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;thread2 run&quot;);</span><br><span class="line">                    System.out.println(&quot;notify t1&quot;);</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    o.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果是</span><br><span class="line">//    thread1 run</span><br><span class="line">//    notify t2</span><br><span class="line">//    thread1 wait</span><br><span class="line">//    thread2 run</span><br><span class="line">//    notify t1</span><br><span class="line">//    thread2 wait</span><br><span class="line">//    thread1 run</span><br><span class="line">//    notify t2</span><br><span class="line">//不断循环</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>​ <strong>本文作者：</strong> h2pl</li><li>​ <strong>本文链接：</strong> <a href="http://h2pl.github.io/2018/05/04/javase16/" target="_blank" rel="noopener">http://h2pl.github.io/2018/05/04/javase16/</a></li><li>​ <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank" rel="noopener">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul><p>​ <a href="https://h2pl.github.io/2018/05/02/javase15/" target="_blank" rel="noopener">Java基础15：深入剖析Java枚举类</a></p><p>​ <a href="https://h2pl.github.io/2018/05/04/javase17/" target="_blank" rel="noopener">Java基础17：Java IO流总结</a></p><p>​</p><iframe title="livere" scrolling="no" src="https://was.livere.me/comment/city?id=city&amp;refer=h2pl.github.io%2F2018%2F05%2F04%2Fjavase16%2F&amp;uid=MTAyMC8zNTkxMC8xMjQ0Ng%3D%3D&amp;site=http%3A%2F%2Fh2pl.github.io%2F2018%2F05%2F04%2Fjavase16%2Findex.html&amp;title=Java%E5%9F%BA%E7%A1%8016%EF%BC%9AJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%9C%80%E5%85%A8%E6%80%BB%E7%BB%93&amp;logo=http%3A%2F%2Fincdn1.b0.upaiyun.com%2F2017%2F10%2F0daf3c6197b0a14eef74a013a154024a.png" style="min-width:100%;width:100px;height:333px;overflow:hidden;border:0 none;z-index:124212" id="lv-comment-203" frameborder="0"></iframe><ul><li>​ 文章目录</li><li>​ 站点概览</li></ul><ol><li><a href="https://h2pl.github.io/2018/05/04/javase16/#Java中的线程" target="_blank" rel="noopener">1. Java中的线程</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#Java线程内存模型" target="_blank" rel="noopener">2. Java线程内存模型</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#构造方法和守护线程" target="_blank" rel="noopener">3. 构造方法和守护线程</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#启动线程的方式和isAlive方法" target="_blank" rel="noopener">4. 启动线程的方式和isAlive方法</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#优先级" target="_blank" rel="noopener">5. 优先级</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#线程的控制方法" target="_blank" rel="noopener">6. 线程的控制方法</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#Thread的静态方法" target="_blank" rel="noopener">7. Thread的静态方法</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#线程组" target="_blank" rel="noopener">8. 线程组</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#多线程的实现" target="_blank" rel="noopener">9. 多线程的实现</a></li><li><a href="https://h2pl.github.io/2018/05/04/javase16/#线程状态转换" target="_blank" rel="noopener">10. 线程状态转换</a></li></ol></div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height:28px;height:28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/11/16/Java基础17：clone与深拷贝，浅拷贝/" class="next">Java基础17：clone与深拷贝，浅拷贝</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MDgxOS8xNzM0NA=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-多线程"><span class="toc-text">1. 多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-线程状态"><span class="toc-text">2. 线程状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-创建线程"><span class="toc-text">3. 创建线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-启动线程"><span class="toc-text">4. 启动线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-线程中断"><span class="toc-text">5. 线程中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程组"><span class="toc-text">线程组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程的实现"><span class="toc-text">多线程的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程状态转换"><span class="toc-text">线程状态转换</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"> <i class="fa fa-xie">最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/Java基础18：多线程/">Java基础18：多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Java基础17：clone与深拷贝，浅拷贝/">Java基础17：clone与深拷贝，浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合7：HashSet-TreeSet与LinkedHashSet/">Java集合7：HashSet,TreeSet与LinkedHashSet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合6：TreeMap/">Java集合6：TreeMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合5：LinkedHashMap与LRU/">Java集合5：LinkedHashMap与LRU</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合4：HashMap与HashTable/">Java集合4：HashMap与HashTable</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合3：Iterator-fail-fast机制与比较器/">Java集合3：Iterator,fail-fast机制与比较器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合2：LinkedList与Queue/">Java集合2：LinkedList与Queue</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合1：ArrayList-Vector与Stack/">Java集合1：ArrayList,Vector与Stack</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java8新特性/">Java8新特性</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-gui">分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发/">Java并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java集合/">Java集合</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-biao">标签</i></div><div class="tagcloud"><a href="/tags/Docker/" style="font-size:15px">Docker</a> <a href="/tags/Java/" style="font-size:15px">Java</a> <a href="/tags/SpringBoot/" style="font-size:15px">SpringBoot</a> <a href="/tags/Slf4j/" style="font-size:15px">Slf4j</a> <a href="/tags/Log4j/" style="font-size:15px">Log4j</a> <a href="/tags/Log4j2/" style="font-size:15px">Log4j2</a> <a href="/tags/demo/" style="font-size:15px">demo</a> <a href="/tags/JDBC/" style="font-size:15px">JDBC</a> <a href="/tags/Jpa/" style="font-size:15px">Jpa</a> <a href="/tags/JdbcTemplate/" style="font-size:15px">JdbcTemplate</a> <a href="/tags/Yaml/" style="font-size:15px">Yaml</a> <a href="/tags/Web/" style="font-size:15px">Web</a></div></div><div class="widget"><div class="widget-title"> <i class="fa fa-archive">归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-you">友情链接</i></div><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test1" target="_blank">test1</a><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test2" target="_blank">test2</a><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test3" target="_blank">test3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p> <span>Copyright &copy;<a href="/." rel="nofollow">Joe.</a></span> <span>Count by <a href="http://busuanzi.ibruce.info/">busuanzi.</a></span> <span>Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a></span></p></div></div></div><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>with(window._bd_share_config={common:{bdSnsKey:{},bdText:"",bdMini:"2",bdMiniList:["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],bdPic:"",bdStyle:"1",bdSize:"16"},share:{},image:{viewList:["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],viewText:"分享到：",viewSize:"16"},selectShare:{bdContainerClass:null,bdSelectMiniList:["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}},document)(getElementsByTagName("head")[0]||head).appendChild(createElement("script")).src="http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)</script><script>!function(e,t){var c,n=e.getElementsByTagName("body")[0];"function"!=typeof LivereTower&&((c=e.createElement("script")).src="https://cdn-city.livere.com/js/embed.dist.js",c.async=!0,n.appendChild(c))}(document)</script></body></html>
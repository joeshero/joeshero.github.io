<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Write Once,Run Anywhere"><meta name="keywords" content="Java,并发,JVM,Spring,Spring Boot,源码,架构"><title>Java基础12：Java Class类和Object类 | Joe's Blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java基础12：Java Class类和Object类</h1><a id="logo" href="/.">Joe's Blog</a><p class="description">Learning Java</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java基础12：Java Class类和Object类</h1><div class="post-meta"><a href="/2018/11/08/Java基础12：Java-Class类和Object类/#comments" class="comment-count"></a><p><span class="date">Nov 08, 2018</span><span><a href="/categories/Java基础/" class="category">Java基础</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="1-Class类"><a href="#1-Class类" class="headerlink" title="1. Class类"></a>1. Class类</h1><blockquote>
<p><a href="https://blog.csdn.net/a724888/article/details/80153002" target="_blank" rel="noopener">参考程序员江湖</a></p>
</blockquote>
<p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。</p>
<p>这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p>
<p><strong>Class类也是类的一种，只是名字和class关键字高度相似。Java是大小写敏感的语言。</strong></p>
<blockquote>
<p><strong>Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象</strong></p>
<p><strong>Class类的对象不能像普通类一样，以 new shapes() 的方式创建，它的对象只能由JVM创建，因为这个类没有public构造函数</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANNOTATION= <span class="number">0x00002000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENUM      = <span class="number">0x00004000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x00001000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//私有构造方法，只能jvm实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        classLoader = loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Class类的作用是运行时提供或获得某个对象的类型信息</p>
<p>我们都知道所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象。</p>
<p>我们自己无法生成一个Class对象（构造函数为private)，而 这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过该方法可以动态地将字节码转为一个Class类对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图所示：</p>
<p><img src="http://dl.iteye.com/upload/picture/pic/101542/0047a6e9-6608-3c3c-a67c-d8ee95e7fcb8.jpg" alt=""></p>
<h1 id="2-获取Class对象"><a href="#2-获取Class对象" class="headerlink" title="2. 获取Class对象"></a>2. 获取Class对象</h1><p>请注意，以下这些方法都是值、指某个类对应的Class对象已经在堆中生成以后，我们通过不同方式获取对这个Class对象的引用。而上面说的DefineClass才是真正将字节码加载到虚拟机的方法，会在堆中生成新的一个Class对象。</p>
<blockquote>
<p>Class.forName()方法</p>
<p>public class shapes{}</p>
<p>Class obj= Class.forName(“shapes”);//类的全限定名</p>
</blockquote>
<blockquote>
<p>第二种办法，使用对象的getClass()函数</p>
<p>public class shapes{}</p>
<p>shapes s1=new shapes();</p>
<p>Class obj=s1.getClass();</p>
<p>Class obj1=s1.getSuperclass();//这个函数作用是获取shapes类的父类的类型</p>
</blockquote>
<blockquote>
<p>第三种办法，使用类字面常量</p>
<p>Class obj=String.class;<br>Class obj1=int.class;<br><strong>注意，使用这种办法生成Class类对象时，不会使JVM自动加载该类（如String类）。==而其他办法会使得JVM初始化该类。==</strong></p>
</blockquote>
<h1 id="3-生成目标类的实例"><a href="#3-生成目标类的实例" class="headerlink" title="3. 生成目标类的实例"></a>3. 生成目标类的实例</h1><p>获取一个Class类的对象后，可以用 newInstance() 函数来生成目标类的一个实例。然而，<strong>该函数并不能直接生成目标类的实例，只能生成object类的实例</strong></p>
<blockquote>
<p>Class obj=Class.forName(“shapes”);<br>Object ShapesInstance=obj.newInstance();<br>使用泛化Class引用生成带类型的目标实例</p>
</blockquote>
<blockquote>
<p>Class obj=shapes.class;<br>shapes newShape=obj.newInstance();</p>
<p>因为有了类型限制，所以使用泛化Class语法的对象引用不能指向别的类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    Class obj1 = <span class="keyword">int</span>.class;</span><br><span class="line">    Class&lt;Integer&gt; obj2 = <span class="keyword">int</span>.class;</span><br><span class="line">    obj1=<span class="keyword">double</span>.class;</span><br><span class="line">    <span class="comment">//obj2=double.class; 这一行代码是非法的，obj2不能改指向别的类 然而，有个灵活的用法，使得你可以用Class的对象指向基类的任何子类。</span></span><br><span class="line">    Class&lt;? extends Number&gt; obj = <span class="keyword">int</span>.class;</span><br><span class="line">    obj=Number .class;</span><br><span class="line">    obj=<span class="keyword">double</span>.class;</span><br><span class="line">    <span class="comment">//因此，以下语法生成的Class对象可以指向任何类。</span></span><br><span class="line">    Class&lt;?&gt; obj = <span class="keyword">int</span>.class;</span><br><span class="line">    obj=<span class="keyword">double</span>.class;</span><br><span class="line">    obj=shapes .class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个奇怪的用法是，当你使用这种泛型语法来构建你手头有的一个Class类的对象的基类对象时，必须采用以下的特殊语法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shapes</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">round</span> <span class="keyword">extends</span> <span class="title">shapes</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;round&gt; rclass = round.class;</span><br><span class="line">    Class&lt;? <span class="keyword">super</span> round&gt; sclass = rclass.getSuperClass();</span><br><span class="line"><span class="comment">//Class&lt;shapes&gt; sclass=rclass.getSuperClass(); 我们明知道，round的基类就是shapes，但是却不能直接声明 Class &lt; shapes &gt;，必须使用特殊语法 Class &lt; ? super round &gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>API</p>
<p><strong>getClassLoader**</strong>()** </p>
<p>获取该类的类装载器。 </p>
<p><strong>getComponentType()</strong> </p>
<p>如果当前类表示一个数组，则返回表示该数组组件的Class对象，否则返回null。 </p>
<p><strong>getConstructor(Class[])</strong> </p>
<p>返回当前Class对象表示的类的指定的公有构造子对象。 </p>
<p><strong>getConstructors()</strong> </p>
<p>返回当前Class对象表示的类的所有公有构造子对象数组。 </p>
<p><strong>getDeclaredConstructor(Class[])</strong> </p>
<p>返回当前Class对象表示的类的指定已说明的一个构造子对象。 </p>
<p><strong>getDeclaredConstructors()</strong> </p>
<p>返回当前Class对象表示的类的所有已说明的构造子对象数组。 </p>
<p><strong>getDeclaredField(String)</strong> </p>
<p>返回当前Class对象表示的类或接口的指定已说明的一个域对象。 </p>
<p><strong>getDeclaredFields()</strong> </p>
<p>返回当前Class对象表示的类或接口的所有已说明的域对象数组。 </p>
<p><strong>getDeclaredMethod(String,Class[])</strong> </p>
<p>返回当前Class对象表示的类或接口的指定已说明的一个方法对象。 </p>
<p><strong>getDeclaredMethods()</strong> </p>
<p>返回Class对象表示的类或接口的所有已说明的方法数组。 </p>
<p><strong>getField(String)</strong> </p>
<p>返回当前Class对象表示的类或接口的指定的公有成员域对象。 </p>
<p><strong>getFields()</strong> </p>
<p>返回当前Class对象表示的类或接口的所有可访问的公有域对象数组。 </p>
<p><strong>getInterfaces()</strong> </p>
<p>返回当前对象表示的类或接口实现的接口。 </p>
<p><strong>getMethod(String,Class[])</strong> </p>
<p>返回当前Class对象表示的类或接口的指定的公有成员方法对象。 </p>
<p><strong>getMethods()</strong> </p>
<p>返回当前Class对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。 </p>
<p><strong>getModifiers()</strong> </p>
<p>返回该类或接口的Java语言修改器代码。 </p>
<p><strong>getName()</strong> </p>
<p>返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。 </p>
<p><strong>getResource(String)</strong> </p>
<p>按指定名查找资源。 </p>
<p><strong>getResourceAsStream(String)</strong> </p>
<p>用给定名查找资源。 </p>
<p><strong>getSigners()</strong> </p>
<p>获取类标记。 </p>
<p><strong>getSuperclass()</strong> </p>
<p>如果此对象表示除Object外的任一类,那么返回此对象的父类对象。 </p>
<p><strong>isArray()</strong> </p>
<p>如果Class对象表示一个数组则返回true,否则返回false。 </p>
<p><strong>isAssignableFrom(Class)</strong> </p>
<p>判定Class对象表示的类或接口是否同参数指定的Class表示的类或接口相同，或是其父类。 </p>
<p><strong>isInstance(Object)</strong> </p>
<p>此方法是Java语言instanceof操作的动态等价方法。 </p>
<p><strong>isInterface()</strong> </p>
<p>判定指定的Class对象是否表示一个接口类型。 </p>
<p><strong>isPrimitive()</strong> </p>
<p>判定指定的Class对象是否表示一个Java的基类型。 </p>
<p><strong>newInstance()</strong> </p>
<p>创建类的新实例。 </p>
<p><strong>toString()</strong> </p>
<p>将对象转换为字符串。 </p>
</blockquote>
<h1 id="4-Object类"><a href="#4-Object类" class="headerlink" title="4. Object类"></a>4. Object类</h1><blockquote>
<p><a href="http://ihenu.iteye.com/blog/2233249" target="_blank" rel="noopener">参考 a Javaer</a></p>
</blockquote>
<p>Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。</p>
<p>Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法，其中9个被所有子类继承</p>
<h2 id="4-1-public-Object"><a href="#4-1-public-Object" class="headerlink" title="4. 1 public Object();"></a>4. 1 public Object();</h2><blockquote>
<p>大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。</p>
<p>为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。</p>
<p>当然，并不是所有的类都是通过此种方式去构建，也自然的，并不是所有的类构造函数都是public。</p>
</blockquote>
<h2 id="4-2-private-static-native-void-registerNatives"><a href="#4-2-private-static-native-void-registerNatives" class="headerlink" title="4.2 private static native void registerNatives();"></a>4.2 <strong>private static native void registerNatives();</strong></h2><p>registerNatives函数前面有native关键字修饰<strong>，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。</strong></p>
<p>方法的具体实现体在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。</p>
<p>既然如此，可能有人会问，registerNatives()修饰符为private，且并没有执行，作用何以达到？其实，在Java源码中，此方法的声明后有紧接着一段静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line"></span><br><span class="line">   registerNatives();  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-protected-native-Object-clone-throws-CloneNotSupportedException"><a href="#4-3-protected-native-Object-clone-throws-CloneNotSupportedException" class="headerlink" title="4.3 protected native Object clone() throws CloneNotSupportedException;"></a>4.3 <strong>protected native Object clone() throws CloneNotSupportedException;</strong></h2><blockquote>
<p>看，clode()方法又是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone英文翻译为”克隆”。Java术语表述为：<strong>clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。</strong> </p>
</blockquote>
<p>明白了clone的含义后，接下来看看如果调用clone()函数对象进行此克隆操作。</p>
<p>首先看一下下面的这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.corn.objectsummary;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.corn.Person;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();  </span><br><span class="line">        <span class="comment">//下面代码出错 The method clone() from the type Object is not visible  </span></span><br><span class="line">        Object clone = o1.clone();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>回到Object类中clone()方法的定义，可以看到其被声明为protected，估计问题就在这上面了，<strong>protected修饰的属性或方法表示：在同一个包内或者不同包的子类可以访问。</strong>显然，Object类与ObjectTest类在不同的包中，但是ObjectTest继承自Object，是Object类的子类，于是，现在却出现子类中通过Object引用不能访问protected方法，原因在于对”不同包中的子类可以访问”没有正确理解。 </p>
</blockquote>
<p>“不同包中的子类可以访问”，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。  在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外）</p>
<blockquote>
<p>下面代码因为此时的主调已经是子类的引用了，所以正常编译，但运行时会报错</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.corn.objectsummary;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        ObjectTest ot1 = <span class="keyword">new</span> ObjectTest();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ObjectTest ot2 = (ObjectTest) ot1.clone();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在运行过程中会抛出”java.lang.CloneNotSupportedException”,表明clone()方法并未正确执行完毕，问题的原因在与Java中的语法规定：</p>
<p><strong>clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。</strong></p>
<p><strong>clone方法实现的是浅拷贝，只拷贝当前对象，并且在堆中分配新的空间，放这个复制的对象。但是对象如果里面有其他类的子对象，那么就不会拷贝到新的对象中。</strong></p>
<p>深拷贝和浅拷贝的区别</p>
<blockquote>
<p>浅拷贝<br>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<p>深拷贝<br>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的。</p>
</blockquote>
<h2 id="4-4-public-final-native-Class-lt-gt-getClass"><a href="#4-4-public-final-native-Class-lt-gt-getClass" class="headerlink" title="4.4 public final native Class&lt;?&gt; getClass();"></a>4.4 <strong>public final native Class&lt;?&gt; getClass();</strong></h2><p>getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。</p>
<blockquote>
<p>首先解释下”类对象”的概念：<strong>在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</strong></p>
</blockquote>
<h2 id="4-5-public-boolean-equals-Object-obj"><a href="#4-5-public-boolean-equals-Object-obj" class="headerlink" title="4.5 public boolean equals(Object obj);"></a>4.5 <strong>public boolean equals(Object obj);</strong></h2><p>==与equals在Java中经常被使用，大家也都知道==与equals的区别：</p>
<p>==表示的是变量值完全相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）；</p>
<p>equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。</p>
<p>实际上，上面说法是不严谨的，更多的只是常见于String类中。首先看一下Object类中关于equals()方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，Object原生的equals()方法内部调用的正是==，与==具有相同的含义。既然如此，为什么还要定义此equals()方法？</p>
<p>equlas()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？</p>
<blockquote>
<p>如上，在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到object基类。</p>
</blockquote>
<p>Java中的约定：重写equals()方法必须重写hasCode()方法。</p>
<h2 id="4-6-public-native-int-hashCode"><a href="#4-6-public-native-int-hashCode" class="headerlink" title="4.6 public native int hashCode();"></a>4.6 <strong>public native int hashCode();</strong></h2><p>hashCode()方法返回一个整形数值，表示该对象的哈希码值。</p>
<p>hashCode()具有如下约定：</p>
<p>1).在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致;</p>
<p>2)<strong>.如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等；</strong></p>
<p>3).<strong>反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等</strong>。</p>
<p>即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt;  equals()相等  =&gt;  hashCode()相等。因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等  =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。</p>
<h2 id="4-7-public-String-toString"><a href="#4-7-public-String-toString" class="headerlink" title="4.7 public String toString();"></a>4.7 <strong>public String toString();</strong></h2><p>toString()方法返回该对象的字符串表示。先看一下Object中的具体方法体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。</p>
<p>getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。</p>
<p>toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。</p>
<h2 id="4-8-4-12-wait-…-notify-…-notifyAll"><a href="#4-8-4-12-wait-…-notify-…-notifyAll" class="headerlink" title="4.8 - 4.12 wait(…)/notify(…)/notifyAll()"></a>4.8 - 4.12 wait(…)/notify(…)/notifyAll()</h2><p>wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。</p>
<p>wait(long timeout)/wait(long timeout, int nanos)：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notisfy()/notisfyAll()方法，或超过指定的超时时间量。</p>
<p>notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。</p>
<blockquote>
<p><strong>wait(…)/notify()|notifyAll()方法只能在同步代码块中才能使用。</strong></p>
</blockquote>
<p>为什么却是Object这个基类所具有的方法？原因在于理论上任何对象都可以视为线程同步中的监听器，且wait(…)/notify()|notifyAll()方法只能在同步代码块中才能使用。</p>
<blockquote>
<p>wait源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">     wait(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>且wait(long timeout, int nanos)方法定义内部实质上也是通过调用wait(long timeout)完成。而wait(long timeout)是一个native方法。因此，wait(…)方法本质上都是native方式实现。</p>
<p>notify()/notifyAll()方法也都是native方法。</p>
<h2 id="4-13-protected-void-finalize"><a href="#4-13-protected-void-finalize" class="headerlink" title="4.13  protected void finalize();"></a>4.13  <strong>protected void finalize();</strong></h2><p>finalize方法主要与Java垃圾回收机制有关。首先我们看一下finalized方法在Object中的具体定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现Object类中finalize方法被定义成一个空方法，为什么要如此定义呢？finalize方法的调用时机是怎么样的呢？</p>
<blockquote>
<p>首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）</p>
</blockquote>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/11/08/Java基础13：Java反射/" class="pre">Java基础13：Java反射</a><a href="/2018/11/08/Java基础11：Java泛型详解/" class="next">Java基础11：Java泛型详解</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MDgxOS8xNzM0NA=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Class类"><span class="toc-text">1. Class类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-获取Class对象"><span class="toc-text">2. 获取Class对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-生成目标类的实例"><span class="toc-text">3. 生成目标类的实例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Object类"><span class="toc-text">4. Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-public-Object"><span class="toc-text">4. 1 public Object();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-private-static-native-void-registerNatives"><span class="toc-text">4.2 private static native void registerNatives();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-protected-native-Object-clone-throws-CloneNotSupportedException"><span class="toc-text">4.3 protected native Object clone() throws CloneNotSupportedException;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-public-final-native-Class-lt-gt-getClass"><span class="toc-text">4.4 public final native Class&lt;?&gt; getClass();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-public-boolean-equals-Object-obj"><span class="toc-text">4.5 public boolean equals(Object obj);</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-public-native-int-hashCode"><span class="toc-text">4.6 public native int hashCode();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-public-String-toString"><span class="toc-text">4.7 public String toString();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-4-12-wait-…-notify-…-notifyAll"><span class="toc-text">4.8 - 4.12 wait(…)/notify(…)/notifyAll()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-protected-void-finalize"><span class="toc-text">4.13  protected void finalize();</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/Java基础18：多线程/">Java基础18：多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Java基础17：clone与深拷贝，浅拷贝/">Java基础17：clone与深拷贝，浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合7：HashSet-TreeSet与LinkedHashSet/">Java集合7：HashSet,TreeSet与LinkedHashSet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合6：TreeMap/">Java集合6：TreeMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合5：LinkedHashMap与LRU/">Java集合5：LinkedHashMap与LRU</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合4：HashMap与HashTable/">Java集合4：HashMap与Hashtable</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合3：Iterator-fail-fast机制与比较器/">Java集合3：Iterator,fail-fast机制与比较器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合2：LinkedList与Queue/">Java集合2：LinkedList与Queue</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合1：ArrayList-Vector与Stack/">Java集合1：ArrayList,Vector与Stack</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java8新特性/">Java8新特性</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发/">Java并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java集合/">Java集合</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Slf4j/" style="font-size: 15px;">Slf4j</a> <a href="/tags/Log4j/" style="font-size: 15px;">Log4j</a> <a href="/tags/Log4j2/" style="font-size: 15px;">Log4j2</a> <a href="/tags/demo/" style="font-size: 15px;">demo</a> <a href="/tags/JDBC/" style="font-size: 15px;">JDBC</a> <a href="/tags/Jpa/" style="font-size: 15px;">Jpa</a> <a href="/tags/JdbcTemplate/" style="font-size: 15px;">JdbcTemplate</a> <a href="/tags/Yaml/" style="font-size: 15px;">Yaml</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test1" target="_blank">test1</a><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test2" target="_blank">test2</a><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test3" target="_blank">test3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Joe.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>
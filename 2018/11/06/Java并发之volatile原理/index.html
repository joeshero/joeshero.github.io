<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Write Once,Run Anywhere"><meta name="keywords" content="Java,并发,JVM,Spring,Spring Boot,源码,架构"><title>Java并发之volatile原理 | Joe's Blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并发之volatile原理</h1><a id="logo" href="/.">Joe's Blog</a><p class="description">Learning Java</p></div><div id="nav-menu"> <a href="/." class="current"><i class="fa fa-home">首页</i></a> <a href="/archives/"><i class="fa fa-archive">归档</i></a> <a href="/about/"><i class="fa fa-user">关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java并发之volatile原理</h1><div class="post-meta"><a href="/2018/11/06/Java并发之volatile原理/#comments" class="comment-count"></a><p><span class="date">Nov 06, 2018</span><span><a href="/categories/Java并发/" class="category">Java并发</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>虽然synchronized可以保证并发时的<strong>原子性，有序性和可见性</strong>，但是由于它本身是一个重量级锁，尽管JVM对它进行了优化，但是在线程上下文切换时仍然难以确保很好的效率。此外，面对着大多数业务场景下都不会发生多线程并发的时候，使用synchronized未免有些奢侈。对于volatile关键字，它的使用成本比synchronized低很多，因为它不会引起线程上下文的切换。Java语言规范对volatile的定义如下：</p><blockquote><p>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。</p></blockquote><p>直白地说，如果一个变量被volatile修饰，Java可以确保它的可见性和有序性，但不能保证对于它操作的原子性。即，<strong>虚拟机只是保证从主内存加载到线程内存的值永远是最新的。</strong></p><h1 id="1-操作系统语义"><a href="#1-操作系统语义" class="headerlink" title="1. 操作系统语义"></a>1. 操作系统语义</h1><p>计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中涉及到数据的读写。为了匹配cpu运行速度和主存速度的不一致性，引入了CPU高速缓存。CPU高速缓存为某个CPU所独有，只与在该CPU运行的线程有关。</p><p><strong>带来的问题：数据的一致性</strong></p><p>例如：对于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i++;</span><br></pre></td></tr></table></figure><p>如果有两个线程同时执行这段代码，首先会将i的初始值读到各自的缓存中再进行自增操作。之后再将自增后的值写回到主内存中。这样带来的问题是最后i只自增了一次。</p><p>解决缓存一致性的方法有：</p><ol><li>通过在总线加LOCK#锁的方式</li><li>通过缓存一致性协议</li></ol><p>方案一是通过一种独占式的方式来实现，在总线加LOCK#锁的话，只能有一个CPU能够执行，其他CPU处于阻塞状态，效率较低。</p><p>方案二，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。</p><h1 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2. Java内存模型"></a>2. Java内存模型</h1><p>详见之后文章。</p><h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h2><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（<strong>注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double</strong>）。要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。</p><p><strong>volatile是无法保证复合操作的原子性</strong></p><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。</p><p><strong>Java提供了volatile来保证可见性。</strong></p><p>当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。当然，synchronize和锁都可以保证可见性。</p><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><p>在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。</p><p><strong>Java提供volatile来保证一定的有序性。</strong></p><h1 id="3-volatile原理"><a href="#3-volatile原理" class="headerlink" title="3. volatile原理"></a>3. volatile原理</h1><h2 id="1-LOCK-前缀指令（可见性）"><a href="#1-LOCK-前缀指令（可见性）" class="headerlink" title="1. LOCK#前缀指令（可见性）"></a>1. LOCK#前缀指令（可见性）</h2><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ul><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</p><p>如果对声明了volatile的变量进行操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回内存如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。</p><p>所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里 。</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/3.png" alt="共享变量的状态示意图"></p><p><strong>lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。</strong></p><h2 id="2-happens-before原则（有序性）"><a href="#2-happens-before原则（有序性）" class="headerlink" title="2. happens before原则（有序性）"></a>2. happens before原则（有序性）</h2><p>在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：</p><ol><li>编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</li><li>处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；</li></ol><p>指令重排序对单线程没有什么影响，他不会影响程序的运行结果，但是会影响多线程的正确性。既然指令重排序会影响到多线程执行的正确性，那么我们就需要禁止重排序。那么JVM是如何禁止重排序的呢？这个问题稍后回答，我们先看另一个原则happens-before，happen-before原则保证了程序的“有序性”，它规定如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。其定义如下：</p><ol><li>同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。</li><li>监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）</li><li>对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）</li><li>线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）</li><li>线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。</li><li>如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个线程执行writer,一个线程执行reader</p><p>根据程序执行次序,1 happens before 2,3 happens before 4</p><p>根据volatile原则，2 happens before 3</p><p>根据传递性，1 happens before 4</p><p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/1.png" alt="示意图"></p><h2 id="3-内存屏障（禁止特定类型的处理器重排序）"><a href="#3-内存屏障（禁止特定类型的处理器重排序）" class="headerlink" title="3. 内存屏障（禁止特定类型的处理器重排序）"></a>3. 内存屏障（禁止特定类型的处理器重排序）</h2><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p></div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height:28px;height:28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/11/08/Java并发之Java内存模型/" class="pre">Java并发之Java内存模型</a><a href="/2018/11/06/Java并发之synchronized原理/" class="next">Java并发之synchronized原理</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MDgxOS8xNzM0NA=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-操作系统语义"><span class="toc-text">1. 操作系统语义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Java内存模型"><span class="toc-text">2. Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-原子性"><span class="toc-text">1. 原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-可见性"><span class="toc-text">2. 可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-有序性"><span class="toc-text">3. 有序性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-volatile原理"><span class="toc-text">3. volatile原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-LOCK-前缀指令（可见性）"><span class="toc-text">1. LOCK#前缀指令（可见性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-happens-before原则（有序性）"><span class="toc-text">2. happens before原则（有序性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-内存屏障（禁止特定类型的处理器重排序）"><span class="toc-text">3. 内存屏障（禁止特定类型的处理器重排序）</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"> <i class="fa fa-xie">最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/Java基础18：多线程/">Java基础18：多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Java基础17：clone与深拷贝，浅拷贝/">Java基础17：clone与深拷贝，浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合7：HashSet-TreeSet与LinkedHashSet/">Java集合7：HashSet,TreeSet与LinkedHashSet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合6：TreeMap/">Java集合6：TreeMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合5：LinkedHashMap与LRU/">Java集合5：LinkedHashMap与LRU</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合4：HashMap与Hashtable/">Java集合4：HashMap与Hashtable</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合3：Iterator-fail-fast机制与比较器/">Java集合3：Iterator,fail-fast机制与比较器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合2：LinkedList与Queue/">Java集合2：LinkedList与Queue</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java集合1：ArrayList-Vector与Stack/">Java集合1：ArrayList,Vector与Stack</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Java8新特性/">Java8新特性</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-gui">分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发/">Java并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java集合/">Java集合</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-biao">标签</i></div><div class="tagcloud"><a href="/tags/Docker/" style="font-size:15px">Docker</a> <a href="/tags/Java/" style="font-size:15px">Java</a> <a href="/tags/SpringBoot/" style="font-size:15px">SpringBoot</a> <a href="/tags/Slf4j/" style="font-size:15px">Slf4j</a> <a href="/tags/Log4j/" style="font-size:15px">Log4j</a> <a href="/tags/Log4j2/" style="font-size:15px">Log4j2</a> <a href="/tags/demo/" style="font-size:15px">demo</a> <a href="/tags/JDBC/" style="font-size:15px">JDBC</a> <a href="/tags/Jpa/" style="font-size:15px">Jpa</a> <a href="/tags/JdbcTemplate/" style="font-size:15px">JdbcTemplate</a> <a href="/tags/Yaml/" style="font-size:15px">Yaml</a> <a href="/tags/Web/" style="font-size:15px">Web</a></div></div><div class="widget"><div class="widget-title"> <i class="fa fa-archive">归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-you">友情链接</i></div><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test1" target="_blank">test1</a><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test2" target="_blank">test2</a><ul></ul><a href="https://img-blog.csdnimg.cn/2018110615553738.png" title="test3" target="_blank">test3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p> <span>Copyright &copy;<a href="/." rel="nofollow">Joe.</a></span> <span>Count by <a href="http://busuanzi.ibruce.info/">busuanzi.</a></span> <span>Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a></span></p></div></div></div><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>with(window._bd_share_config={common:{bdSnsKey:{},bdText:"",bdMini:"2",bdMiniList:["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],bdPic:"",bdStyle:"1",bdSize:"16"},share:{},image:{viewList:["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],viewText:"分享到：",viewSize:"16"},selectShare:{bdContainerClass:null,bdSelectMiniList:["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}},document)(getElementsByTagName("head")[0]||head).appendChild(createElement("script")).src="http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)</script><script>!function(e,t){var c,n=e.getElementsByTagName("body")[0];"function"!=typeof LivereTower&&((c=e.createElement("script")).src="https://cdn-city.livere.com/js/embed.dist.js",c.async=!0,n.appendChild(c))}(document)</script></body></html>
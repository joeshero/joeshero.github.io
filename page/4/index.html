<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/favicon.ico?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT"><meta name="description" content="Write Once,Run Anywhere"><meta name="keywords" content="Java,并发,JVM,Spring,Spring Boot,源码,架构"><meta property="og:type" content="website"><meta property="og:title" content="Joe&#39;s Blog"><meta property="og:url" content="http://yoursite.com/page/4/index.html"><meta property="og:site_name" content="Joe&#39;s Blog"><meta property="og:description" content="Write Once,Run Anywhere"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Joe&#39;s Blog"><meta name="twitter:description" content="Write Once,Run Anywhere"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/page/4/"><title>Joe's Blog</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Joe's Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Learning Java</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/3204.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/3204.html" itemprop="url">Java基础10：理解Java异常</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:49:17+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1.8k字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">6分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-为什么要使用异常"><a href="#1-为什么要使用异常" class="headerlink" title="1. 为什么要使用异常"></a>1. 为什么要使用异常</h1><p>为了提高程序的健壮性，提高系统可用率。</p><p>首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。</p><p>如果没有异常机制，程序只能通过运行结果推断是否发生异常或者错误。但这样会降低程序的可读性，并且通过结果推断不一定正确，且很难定位异常发生的位置，降低了代码的可用性。</p><p>Java中的异常处理机制保证了代码的健壮性。使用异常可以很方便地捕获到程序运行过程中发生的错误，并且可以集中处理异常，使代码可读性较强。</p><h1 id="2-异常体系"><a href="#2-异常体系" class="headerlink" title="2. 异常体系"></a>2. 异常体系</h1><p><img src="http://img.my.csdn.net/uploads/201212/02/1354439580_6933.PNG" alt="异常结构"></p><p>可以看出，Throwable是Java中所有错误和异常的超类（万物皆可抛）。它有两个子类，Error，Exception</p><blockquote><p><strong>非检查异常</strong>（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。</p><p>对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p></blockquote><blockquote><p><strong>检查异常</strong>（checked exception）：除了Error 和 RuntimeException的其它异常。java强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。</p></blockquote><h1 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h1><p>在异常可能发生的地方，用try-catch-finally(可选)捕获或者throws抛出交给函数调用者处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testException</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    <span class="comment">//FileInputStream的构造函数会抛出FileNotFoundException </span></span><br><span class="line">    FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"E:\\a.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> word;</span><br><span class="line">    <span class="comment">// read方法会抛出IOException </span></span><br><span class="line">    <span class="keyword">while</span> ((word = fileIn.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close方法会抛出IOException </span></span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 异常处理方式 </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//try块中放可能发生异常的代码。 </span></span><br><span class="line">            InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">            <span class="comment">//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。 </span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如果发生异常，则尝试去匹配catch块。 throw new SQLException(); </span></span><br><span class="line">            <span class="comment">// 使用1.8jdk同时捕获多个异常，runtimeException也可以捕获。只是捕获后虚拟机也无法处理，所以不建议捕获。 </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException | IOException | ArrayIndexOutOfBoundsException exception) &#123;</span><br><span class="line">            System.out.println(exception.getMessage());</span><br><span class="line">            <span class="comment">//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。 </span></span><br><span class="line">            <span class="comment">// catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 </span></span><br><span class="line">            <span class="comment">// 在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 </span></span><br><span class="line">            <span class="comment">// 如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。 </span></span><br><span class="line">            <span class="comment">// 如果try中没有发生异常，则所有的catch块将被忽略。 </span></span><br><span class="line">            <span class="comment">//多个catch存在子类Exception在父类Exception之前</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//finally块通常是可选的。 </span></span><br><span class="line">            <span class="comment">// 无论异常是否发生，异常是否匹配被处理，finally都会执行。 </span></span><br><span class="line">            <span class="comment">// finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个try至少由一个catch块或者finally或者都有。</p></blockquote><h1 id="4-throws"><a href="#4-throws" class="headerlink" title="4. throws"></a>4. throws</h1><p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p><p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p><h1 id="5-finally"><a href="#5-finally" class="headerlink" title="5. finally"></a>5. finally</h1><p>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：<strong>System.exit()</strong>。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。</p><p>良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。</p><blockquote><p>需要注意的地方:</p><p>1、finally块没有处理异常的能力。处理异常的只能是catch块。</p><p>2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。</p><p>3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。</p></blockquote><h1 id="6-throw"><a href="#6-throw" class="headerlink" title="6. throw"></a>6. throw</h1><p>自行抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证输入i为正数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArgumentIllegalException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-自定义异常"><a href="#7-自定义异常" class="headerlink" title="7. 自定义异常"></a>7. 自定义异常</h1><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p><p>其中包括</p><p>一个无参构造函数<br>一个带有String参数的构造函数，并传递给父类的构造函数。<br>一个带有String参数和Throwable参数，并都传递给父类构造函数<br>一个带有Throwable 参数的构造函数，并传递给父类的构造函1数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message, cause);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="8-遇到return"><a href="#8-遇到return" class="headerlink" title="8. 遇到return"></a>8. 遇到return</h1><p>在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = bar();</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>finally 中return会覆盖try或catch中return</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = bar();</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;<span class="comment">//不管有没有异常输出都为3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>综上，为了代码可读性和可维护性，尽量不要在try-catch-finally语句中使用finally</strong></p></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/39591.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/39591.html" itemprop="url">Java基础9：深入理解内部类</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:48:43+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1.5k字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">5分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><blockquote><p>内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。内部类主要有以下几类：<strong>成员内部类、局部内部类、静态内部类、匿名内部类</strong></p></blockquote><h1 id="1-1-共性"><a href="#1-1-共性" class="headerlink" title="1.1 共性"></a>1.1 共性</h1><p>(1)内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。</p><p>(2)内部类不能用普通的方式访问。</p><p>(3)内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量 。</p><p>(4)外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问</p><p>内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，<strong>无论是否是private的</strong>。</p><p>因为当某个外围类的对象创建内部类的对象时，此内部类会捕获一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。</p><h2 id="1-2-好处"><a href="#1-2-好处" class="headerlink" title="1.2 好处"></a>1.2 好处</h2><p><strong>静态内部类的作用：</strong></p><p>1 只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类。</p><p>2 由于Java规定静态内部类不能用使用外在类的非静态属性和方法，所以只是为了方便管理类结构而定义。于是我们在创建静态内部类的时候，不需要外部类对象的引用。</p><p><strong>非静态内部类的作用：</strong></p><p>1 内部类继承自某个类或实现某个接口，内部类的代码操作创建其他外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。</p><p>2 使用内部类最吸引人的原因是:每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响</p><p>3 如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。</p><p>从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了”多重继承”。</p><h1 id="2-区别"><a href="#2-区别" class="headerlink" title="2. 区别"></a>2. 区别</h1><h2 id="2-1-那静态内部类与普通内部类有什么区别呢？"><a href="#2-1-那静态内部类与普通内部类有什么区别呢？" class="headerlink" title="2. 1 那静态内部类与普通内部类有什么区别呢？"></a>2. 1 那静态内部类与普通内部类有什么区别呢？</h2><blockquote><p>（1）静态内部类不持有外部类的引用<br>在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性（如果是private权限也能访问，这是由其代码位置所决定的），其他则不能访问。</p><p>（2）静态内部类不依赖外部类<br>普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，也就是说它们会同生同死，一起声明，一起被垃圾回收器回收。而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类还是可以存在的。</p><p>（3）普通内部类不能声明static的方法和变量</p><p>普通内部类不能声明static的方法和变量，注意这里说的是变量，常量（也就是final static修饰的属性）还是可以的，而静态内部类形似外部类，没有任何限制。</p></blockquote><h1 id="3-内部类的加载"><a href="#3-内部类的加载" class="headerlink" title="3. 内部类的加载"></a>3. 内部类的加载</h1><blockquote><p>内部类是延时加载的，也就是说只会在第一次使用时加载。不使用就不加载，所以可以很好的实现单例模式。</p><p>不论是静态内部类还是非静态内部类都是在第一次使用时才会被加载。</p><p>对于非静态内部类是不能出现静态模块（包含静态块，静态属性，静态方法等）</p><p>非静态类的使用需要依赖于外部类的对象</p></blockquote><h1 id="4-成员内部类"><a href="#4-成员内部类" class="headerlink" title="4. 成员内部类"></a>4. 成员内部类</h1><p>类比成员变量，可以被访问修饰符修饰。可以访问外部类的所有变量，包括private。需要依托外部类才能创建。</p><h1 id="5-方法内部类"><a href="#5-方法内部类" class="headerlink" title="5. 方法内部类"></a>5. 方法内部类</h1><p>在方法中定义的内部类称为局部内部类。与局部变量类似，局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，和此外围类所有的成员。</p><p>局部内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。</p><h1 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6. 匿名内部类"></a>6. 匿名内部类</h1><p>简单地说：匿名内部类就是没有名字的内部类，并且，匿名内部类是局部内部类的一种特殊形式。</p><ul><li><p><strong>匿名内部类不能有构造方法</strong>。</p></li><li><p><strong>匿名内部类不能定义任何静态成员、方法和类。</strong></p></li><li><p><strong>匿名内部类不能是public,protected,private,static。只能创建匿名内部类的一个实例。</strong></p></li><li><p><strong>一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。</strong></p></li><li><p><strong>因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。</strong></p></li></ul><p>内部类引用外部方法的参数时，参数必须为final</p></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/45280.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/45280.html" itemprop="url">Java基础8：Java类及包访问权限</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:48:04+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1k字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">3分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-问题：一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#1-问题：一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="1. 问题：一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>1. 问题：一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h1><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。一个文件中可以只有非public类，如果只有一个非public类，此类可以跟文件名不同。</p><h1 id="2-为什么一个java源文件中只能有一个public类？"><a href="#2-为什么一个java源文件中只能有一个public类？" class="headerlink" title="2. 为什么一个java源文件中只能有一个public类？"></a>2. 为什么一个java源文件中只能有一个public类？</h1><p>1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。</p><p>2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。</p><p>3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。</p><h1 id="3-在java文件中是否可以没有public类"><a href="#3-在java文件中是否可以没有public类" class="headerlink" title="3 . 在java文件中是否可以没有public类"></a>3 . 在java文件中是否可以没有public类</h1><p>public类不是必须的，java文件中可以没有public类。</p><h1 id="4-为什么这个public的类的类名必须和文件名相同"><a href="#4-为什么这个public的类的类名必须和文件名相同" class="headerlink" title="4. 为什么这个public的类的类名必须和文件名相同"></a>4. 为什么这个public的类的类名必须和文件名相同</h1><p>是为了方便虚拟机在相应的路径中找到相应的类所对应的字节码文件。</p><h1 id="5-main函数"><a href="#5-main函数" class="headerlink" title="5. main函数"></a>5. main函数</h1><p>作为函数的入口</p><p>public：代表着该函数访问权限是最大的</p><p>static：代表主函数随着类的加载就已经存在了</p><p>void：主函数没有具体的返回值</p><p>main：不是关键字，但是一个特殊的单词，能够被JVM识别（String[] args）：函数的参数，参数类型是一个数组，该数组中的元素师字符串，字符串数组。main(String[] args) 字符串数组的 此时空数组的长度是0，但也可以在 运行的时候向其中传入参数。</p><h1 id="6-外部类的访问权限"><a href="#6-外部类的访问权限" class="headerlink" title="6. 外部类的访问权限"></a>6. 外部类的访问权限</h1><p>外部类只能用public和default修饰。</p><p>为什么要对外部类或类做修饰呢？</p><p>1.存在包概念：public 和 default 能区分这个外部类能对不同包作一个划分 （default修饰的类，其他包中引入不了这个类，public修饰的类才能被import）</p><p>protected是包内可见并且子类可见，但是当一个外部类想要继承一个protected修饰的非同包类时，压根找不到这个类，更别提几层了</p><p>private修饰的外部类，其他任何外部类都无法导入它。</p><p>​</p><table><thead><tr><th>Modifier</th><th>Class</th><th>Package</th><th>Subclass</th><th>World</th></tr></thead><tbody><tr><td><code>public</code></td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td><code>protected</code></td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>no modifier</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td><code>private</code></td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><h1 id="7-Java包的命名规则"><a href="#7-Java包的命名规则" class="headerlink" title="7. Java包的命名规则"></a>7. Java包的命名规则</h1><blockquote><p>以 java.* 开头的是Java的核心包，所有程序都会使用这些包中的类；</p><p>以 javax. <em>开头的是扩展包，x 是 extension 的意思，也就是扩展。虽然 javax.</em> 是对 java. <em>的优化和扩展，但是由于 javax.</em> 使用的越来越多，很多程序都依赖于 javax.，所以 javax. 也是核心的一部分了，也随JDK一起发布。</p><p>以 org.* 开头的是各个机构或组织发布的包，因为这些组织很有影响力，它们的代码质量很高，所以也将它们开发的部分常用的类随JDK一起发布。</p><p>在包的命名方面，为了防止重名，有一个惯例：大家都以自己域名的倒写形式作为开头来为自己开发的包命名，例如百度发布的包会以 com.baidu. <em>开头，w3c组织发布的包会以 org.w3c.</em> 开头，微学苑发布的包会以 net.weixueyuan.* 开头……</p><p>组织机构的域名后缀一般为 org，公司的域名后缀一般为 com，可以认为 org. <em>开头的包为非盈利组织机构发布的包，它们一般是开源的，可以免费使用在自己的产品中，不用考虑侵权问题，而以 com.</em> 开头的包往往由盈利性的公司发布，可能会有版权问题，使用时要注意。</p></blockquote></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/19983.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/19983.html" itemprop="url">Java基础7：代码块与加载顺序</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:46:56+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">404字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">1分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>代码块：用{}包围的代码</p><p>Java中，有</p><ul><li>局部代码块</li><li>静态代码块</li><li>静态代码块</li></ul><h1 id="1-局部代码块"><a href="#1-局部代码块" class="headerlink" title="1. 局部代码块"></a>1. 局部代码块</h1><p>位置：局部位置（方法内部）</p><p>作用：限定变量的生命周期，尽早释放，节约内存</p><p>调用：调用其所在的方法时执行</p><h1 id="2-构造代码块"><a href="#2-构造代码块" class="headerlink" title="2. 构造代码块"></a>2. 构造代码块</h1><p>位置：类成员的位置，就是类中方法之外的位置</p><p>作用：把多个构造方法共同的部分提取出来，共用构造代码块</p><p>调用：每次调用构造方法时，都会优先于构造方法执行，也就是每次new一个对象时自动调用，对 对象的初始化</p><h1 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3. 静态代码块"></a>3. 静态代码块</h1><p>位置：类成员位置，用static修饰的代码块</p><p>作用：对类进行一些初始化 只加载一次，当new多个对象时，只有第一次会调用静态代码块，因为，静态代码块 是属于类的，所有对象共享一份</p><p>调用: new 一个对象时自动调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Joe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple a = <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态代码块</span><br><span class="line">子类静态代码块</span><br><span class="line">父类普通代码块</span><br><span class="line">父类构造函数</span><br><span class="line">子类普通代码块</span><br><span class="line">子类构造函数</span><br></pre></td></tr></table></figure></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/63007.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/63007.html" itemprop="url">Java基础6：抽象类及接口</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:45:52+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">805字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">3分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">M</span> <span class="keyword">extends</span> <span class="title">N</span>,<span class="title">L</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">N</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">L</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 接口 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//变量默认都为public final修饰</span></span><br><span class="line">    <span class="keyword">final</span> A a = <span class="keyword">null</span>;<span class="comment">//基本数据类型和引用都一样</span></span><br><span class="line">    <span class="comment">//protected void a();//报错</span></span><br><span class="line">    <span class="comment">//private //报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;<span class="comment">// 方法都是public abstract修饰的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void b()&#123;&#125; 报错，接口里的方法不能有方法体，也不能有&#123;&#125;，只能有()；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// final void b();</span></span><br><span class="line">    <span class="comment">// 注意，抽象方法不能加final。因为final方法不能被重写。</span></span><br><span class="line">    <span class="comment">//但如果抽象方法不被重写那就没有意义了，因为他根本没有代码体。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 抽象类 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//变量并没有被pulic和final修饰，只是一般的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//抽象类可以有具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AA</span><span class="params">()</span></span>;<span class="comment">//抽象方法没有方法体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//private abstract void B();//报错，组合非法</span></span><br><span class="line">    <span class="comment">// 因为private修饰的方法无法被子类重写，所以和final一样，使抽象方法无法被实现。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类也可以被实例化，举例说明</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    B() &#123;</span><br><span class="line">        System.out.println(<span class="string">"b init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    C()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"c init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 接口对比抽象类 </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        <span class="comment">//结果先实例化B，再实例化C。</span></span><br><span class="line">        <span class="comment">//因为会调用到父类的构造方法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h1><p>高度抽象</p><p>接口可以多继承</p><p>接口中变量默认为public static final修饰，且必须被赋值（不能只定义）</p><p>接口中方法默认为public abstract(JDK1.8中可以有default方法)</p><p>不能有构造器</p><h1 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3. 抽象类"></a>3. 抽象类</h1><p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有<strong>成员变量</strong>和<strong>普通的成员方法</strong>。</p><ul><li><p>抽象类可以有非抽象方法。(不需要必须有抽象方法)</p></li><li><p>abstract可以修饰类，方法，不能修饰字段。</p></li><li><p>抽象方法的body不能有{}，而是;</p></li><li><p>可以有构造器</p></li><li><p>可以有静态方法</p></li><li><strong>不可以用来创建对象，但可以被实例化（继承关系）</strong></li><li>抽象方法可以有public、protected和default这些修饰符</li><li><strong>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</strong></li><li><strong>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</strong></li></ul><h1 id="4-区别"><a href="#4-区别" class="headerlink" title="4. 区别"></a>4. 区别</h1><p>接口可以多继承，抽象类不能</p><p>接口没有构造方法，抽象类可以有</p><p>接口不能有普通成员变量，抽象类可以有</p><p>接口类不可以有普通方法（Java8中可以有默认实现），抽象类可以有</p><p>抽象类中抽象方法类型可以是public,protected,接口中只能为public</p><p>接口中不能有静态方法，抽象类中可以有</p><p>抽象类和接口都可以有静态成员变量，但接口只能是public static final，抽象类任意。</p></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/488.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/488.html" itemprop="url">Java基础5：final关键字</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:45:26+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">286字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">1分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h1><blockquote><p>final修饰类，表示这个类不能被继承</p><p>final修饰方法，表示这个方法不能被重写。</p><p>final修饰变量，如果这个变量指向一个基本类型，则这个变量为一个常量，如果这个变量指向一个对象的引用，则这个变量指向的引用不可变。</p></blockquote><h1 id="2-修饰类"><a href="#2-修饰类" class="headerlink" title="2. 修饰类"></a>2. 修饰类</h1><blockquote><p>一个典型的例子是Java,lang.String类。</p></blockquote><blockquote><p>在这个类中，String被final所修饰，表示这个类不能被继承。此外，在String内部定义了一个char数组，也被final所修饰，且类中没有修改value数组内容的代码。综上，我们可以说String数组虽然没有被synchronized所修饰，但它是线程安全的。</p></blockquote><h1 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3. 修饰方法"></a>3. 修饰方法</h1><blockquote><p>当final修饰方法时，表示这个方法不能被重写。重写基于动态绑定，而final方法在编译阶段绑定，称为静态绑定(static binding)。</p></blockquote><h1 id="4-修饰变量"><a href="#4-修饰变量" class="headerlink" title="4. 修饰变量"></a>4. 修饰变量</h1><blockquote><p>当final修饰成员变量时，必须在声明时初始化或在构造函数中初始化。</p><p>当final修饰局部变量时，必须在声明时赋值。</p></blockquote></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/13047.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/13047.html" itemprop="url">Java基础4：装箱，拆箱，类型转换</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:41:47+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">381字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">1分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-装箱和拆箱"><a href="#1-装箱和拆箱" class="headerlink" title="1. 装箱和拆箱"></a>1. 装箱和拆箱</h1><p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转换。</p><p>基本类型：</p><ul><li>byte</li><li>short</li><li>int</li><li>long</li><li>char</li><li>float</li><li>double</li><li>boolean</li></ul><p>包装类型</p><ul><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Character</li><li>Float</li><li>Double</li><li>Boolean</li></ul><p><strong>简单来说，装箱就是基本类型转换为对象类型，拆箱就是对象类型转换为基本类型。</strong></p><p>通常情况下如果我们要创建一个对象，需要new关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>自动装箱就是Java会自动完成基本类型到包装类型的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;<span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> j = i;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h1 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2. 如何实现"></a>2. 如何实现</h1><p>以Integer为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Integer i = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> n = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反编译class文件：</p><p><img src="https://images0.cnblogs.com/i/288799/201406/101641567956500.jpg" alt="字节码文件"></p><blockquote><p>可知，在装箱调用的是Integer的valueOf()方法，拆箱调用的是Integer的intValue()方法。</p></blockquote><h1 id="3-判断相等"><a href="#3-判断相等" class="headerlink" title="3. 判断相等"></a>3. 判断相等</h1><p>对于下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">100</span>;</span><br><span class="line">Integer i2 = <span class="number">100</span>;</span><br><span class="line">Integer i3 = <span class="number">200</span>;</span><br><span class="line">Integer i4 = <span class="number">200</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//true</span></span><br><span class="line">System.out.println(i3 == i4);<span class="comment">//false</span></span><br><span class="line">System.out.println(i1.equals(i2));<span class="comment">//true</span></span><br><span class="line">System.out.println(i3.equals(i4));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>输出不同的原因是因为缓存池的存在。具体在之前有说过。</p><p><a href="https://joeshero.github.io/2018/11/06/Java%E5%9F%BA%E7%A1%802%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">Java基础2：基本数据类型</a></p><h1 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4. 类型转换"></a>4. 类型转换</h1><p>对于下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 += <span class="number">1</span>;<span class="comment">//可以正常编译通过</span></span><br><span class="line"><span class="keyword">short</span> s1 = s1 + <span class="number">1</span>;<span class="comment">//无法正常编译通过</span></span><br></pre></td></tr></table></figure><p>对于第一种情况，Java在运算 +=，-=，*=，/= 等运算符时会自动进行类型的转换。</p><p>对于第二种情况，s1为short类型，s1 + 1为int类型，不能向下转型，所以报错。</p></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/32270.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/32270.html" itemprop="url">Java并发之CLH同步队列</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:39:33+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">805字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">3分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>AQS内部维护着一个FIFO队列来实现同步，这个队列就是CLH队列。</p><h1 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h1><p>CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理。当前线程如果获取同步状态失败时，AQS会将当前线程已经等待状态等信息构造成一个节点(Node)并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 独占 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示下一次共享式同步状态获取将会无条件地传播下去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前驱节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后继节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取同步状态的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/post/32270/1.png" title="CLH结构"><h1 id="2-入列"><a href="#2-入列" class="headerlink" title="2. 入列"></a>2. 入列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建Node</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//CAS设置尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多次尝试</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>addWaiter(Node node)先通过快速尝试设置尾节点，如果失败，则调用enq(Node node)方法设置尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//多次尝试，直到成功为止</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//设置为尾节点</span></span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> <img src="/post/32270/2.png" title="入列"><h1 id="3-出列"><a href="#3-出列" class="headerlink" title="3. 出列"></a>3. 出列</h1><p>CLH同步队列遵循FIFO，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的next和当前节点的prev即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。过程图如下</p> <img src="/post/32270/3.png" title="出列"><blockquote><p>转自<a href="http://cmsblogs.com/?p=2188" target="_blank" rel="noopener">死磕Java并发之CLH队列</a></p></blockquote></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/21313.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/21313.html" itemprop="url">Java并发之AQS</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:38:58+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1.2k字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">4分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>Java的内置锁一直都是备受争议的，在JDK 1.6之前，synchronized这个重量级锁其性能一直都是较为低下，虽然在1.6后，进行大量的锁优化策略(<a href="https://joeshero.github.io/post/23224.html" target="_blank" rel="noopener">Java并发之synchronized原理</a>,但是与Lock相比synchronized还是存在一些缺陷的：虽然synchronized提供了便捷性的隐式获取锁释放锁机制（基于JVM机制），但是它却缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，且它为独占式在高并发场景下性能大打折扣。</p><p>在介绍Lock之前，我们需要先熟悉一个非常重要的组件，掌握了该组件JUC包下面很多问题都不在是问题了。该组件就是AQS。</p><p>AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（<strong>Doug Lea</strong>）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。</p><p>AQS解决了实现同步器涉及到的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。</p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。</p><p>AQS通过<strong>内置的FIFO同步队列来完成资源获取线程的排队工作</strong>，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><blockquote><p>AQS主要提供了如下一些方法：</p></blockquote><ul><li>getState()：返回同步状态的当前值；</li><li>setState(int newState)：设置当前同步状态；</li><li>compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li><li>tryAcquire(int arg)：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li><li>tryRelease(int arg)：独占式释放同步状态；</li><li>tryAcquireShared(int arg)：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li><li>tryReleaseShared(int arg)：共享式释放同步状态；</li><li>isHeldExclusively()：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li><li>acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li><li>acquireInterruptibly(int arg)：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li><li>tryAcquireNanos(int arg,long nanos)：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li><li>acquireShared(int arg)：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li><li>acquireSharedInterruptibly(int arg)：共享式获取同步状态，响应中断；</li><li>tryAcquireSharedNanos(int arg, long nanosTimeout)：共享式获取同步状态，增加超时限制；</li><li>release(int arg)：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li><li>releaseShared(int arg)：共享式释放同步状态；</li></ul><blockquote><p>转自 <a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">死磕Java并发之A.Q.S简介</a></p></blockquote></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/19599.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/post/19599.html" itemprop="url">Java并发之Java内存模型</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:38:32+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1.5k字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">5分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p><strong>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</strong></p><p><strong>Java 线程之间的通信由 Java 内存模型（JMM）控制。</strong>JMM<br>决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程与主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读／写共享变量的副本。<strong>本地内存是JMM 的一个抽象概念，并不真实存在。</strong></p> <img src="/post/19599/1.jpg" title="JMM抽象示意图"><h1 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1. 主内存与工作内存"></a>1. 主内存与工作内存</h1><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在他们之间加入了高速缓存。</p><p>这样会带来一个问题：<strong>缓存一致性</strong>。如果多个缓存共享同一个主内存区域，那么多个缓存的数据可能会不一致。</p> <img src="/post/19599/2.png"><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p> <img src="/post/19599/3.png"><p>JMM通过控制主内存与每个线程的本地内存之间的交互来为程序提供内存可见性保证。</p><h1 id="2-内存间交互"><a href="#2-内存间交互" class="headerlink" title="2. 内存间交互"></a>2. 内存间交互</h1><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p> <img src="/post/19599/4.png"><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h1 id="3-内存模型三大特性"><a href="#3-内存模型三大特性" class="headerlink" title="3. 内存模型三大特性"></a>3. 内存模型三大特性</h1><h2 id="3-1-原子性"><a href="#3-1-原子性" class="headerlink" title="3.1 原子性"></a>3.1 原子性</h2><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被<br>volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和<br>write 操作可以不具备原子性。</p><h2 id="3-2-可见性"><a href="#3-2-可见性" class="headerlink" title="3.2 可见性"></a>3.2 可见性</h2><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><h2 id="3-3-有序性"><a href="#3-3-有序性" class="headerlink" title="3.3 有序性"></a>3.3 有序性</h2><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加<strong>内存屏障</strong>的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h1 id="4-happens-before"><a href="#4-happens-before" class="headerlink" title="4.happens-before"></a>4.happens-before</h1><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p> <img src="/post/19599/5.jpg"><h1 id="5-as-if-serial"><a href="#5-as-if-serial" class="headerlink" title="5. as-if-serial"></a>5. as-if-serial</h1><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是如果操作之间没有数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//A</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;<span class="comment">//B</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;<span class="comment">//C</span></span><br></pre></td></tr></table></figure><p>上述代码中，依赖关系为</p> <img src="/post/19599/6.jpg"><p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B<br>的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B<br>之间的执行顺序。下图是该程序的两种执行顺序：</p> <img src="/post/19599/7.jpg"></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/iverson.jpg" alt="Joe"><p class="site-author-name" itemprop="name">Joe</p><p class="site-description motion-element" itemprop="description">Write Once,Run Anywhere</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">12</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/joeshero" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Joe</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">84k</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共84k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!1,scale:.3},log:!1,tagMode:!1})</script></body></html>
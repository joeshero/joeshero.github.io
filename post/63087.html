<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/favicon.ico?v=5.1.4" color="#222"><meta name="keywords" content="Java,"><meta name="description" content="1. Class类Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。 这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。"><meta name="keywords" content="Java"><meta property="og:type" content="article"><meta property="og:title" content="Java基础12：Java Class类和Object类"><meta property="og:url" content="http://yoursite.com/post/63087.html"><meta property="og:site_name" content="Joe&#39;s Blog"><meta property="og:description" content="1. Class类Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。 这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/101542/0047a6e9-6608-3c3c-a67c-d8ee95e7fcb8.jpg"><meta property="og:updated_time" content="2019-01-29T03:03:50.485Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java基础12：Java Class类和Object类"><meta name="twitter:description" content="1. Class类Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。 这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。"><meta name="twitter:image" content="http://dl.iteye.com/upload/picture/pic/101542/0047a6e9-6608-3c3c-a67c-d8ee95e7fcb8.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/post/63087.html"><title>Java基础12：Java Class类和Object类 | Joe's Blog</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Joe's Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Learning Java</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/post/63087.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Joe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/iverson.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Joe's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java基础12：Java Class类和Object类</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T00:50:27+08:00">2018-11-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4.7k字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">17分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-Class类"><a href="#1-Class类" class="headerlink" title="1. Class类"></a>1. Class类</h1><p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。</p><p>这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p><a id="more"></a><p><strong>Class类也是类的一种，只是名字和class关键字高度相似。Java是大小写敏感的语言。</strong></p><blockquote><p><strong>Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象</strong></p><p><strong>Class类的对象不能像普通类一样，以 new shapes() 的方式创建，它的对象只能由JVM创建，因为这个类没有public构造函数</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANNOTATION= <span class="number">0x00002000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENUM      = <span class="number">0x00004000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x00001000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//私有构造方法，只能jvm实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        classLoader = loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Class类的作用是运行时提供或获得某个对象的类型信息</p><p>我们都知道所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象。</p><p>我们自己无法生成一个Class对象（构造函数为private)，而 这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过该方法可以动态地将字节码转为一个Class类对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图所示：</p><p><img src="http://dl.iteye.com/upload/picture/pic/101542/0047a6e9-6608-3c3c-a67c-d8ee95e7fcb8.jpg" alt=""></p><h1 id="2-获取Class对象"><a href="#2-获取Class对象" class="headerlink" title="2. 获取Class对象"></a>2. 获取Class对象</h1><p>请注意，以下这些方法都是值、指某个类对应的Class对象已经在堆中生成以后，我们通过不同方式获取对这个Class对象的引用。而上面说的DefineClass才是真正将字节码加载到虚拟机的方法，会在堆中生成新的一个Class对象。</p><blockquote><p>Class.forName()方法</p><p>public class shapes{}</p><p>Class obj= Class.forName(“shapes”);//类的全限定名</p></blockquote><blockquote><p>第二种办法，使用对象的getClass()函数</p><p>public class shapes{}</p><p>shapes s1=new shapes();</p><p>Class obj=s1.getClass();</p><p>Class obj1=s1.getSuperclass();//这个函数作用是获取shapes类的父类的类型</p></blockquote><blockquote><p>第三种办法，使用类字面常量</p><p>Class obj=String.class;<br>Class obj1=int.class;<br><strong>注意，使用这种办法生成Class类对象时，不会使JVM自动加载该类（如String类）。==而其他办法会使得JVM初始化该类。==</strong></p></blockquote><h1 id="3-生成目标类的实例"><a href="#3-生成目标类的实例" class="headerlink" title="3. 生成目标类的实例"></a>3. 生成目标类的实例</h1><p>获取一个Class类的对象后，可以用 newInstance() 函数来生成目标类的一个实例。然而，<strong>该函数并不能直接生成目标类的实例，只能生成object类的实例</strong></p><blockquote><p>Class obj=Class.forName(“shapes”);<br>Object ShapesInstance=obj.newInstance();<br>使用泛化Class引用生成带类型的目标实例</p></blockquote><blockquote><p>Class obj=shapes.class;<br>shapes newShape=obj.newInstance();</p><p>因为有了类型限制，所以使用泛化Class语法的对象引用不能指向别的类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    Class obj1 = <span class="keyword">int</span>.class;</span><br><span class="line">    Class&lt;Integer&gt; obj2 = <span class="keyword">int</span>.class;</span><br><span class="line">    obj1=<span class="keyword">double</span>.class;</span><br><span class="line">    <span class="comment">//obj2=double.class; 这一行代码是非法的，obj2不能改指向别的类 然而，有个灵活的用法，使得你可以用Class的对象指向基类的任何子类。</span></span><br><span class="line">    Class&lt;? extends Number&gt; obj = <span class="keyword">int</span>.class;</span><br><span class="line">    obj=Number .class;</span><br><span class="line">    obj=<span class="keyword">double</span>.class;</span><br><span class="line">    <span class="comment">//因此，以下语法生成的Class对象可以指向任何类。</span></span><br><span class="line">    Class&lt;?&gt; obj = <span class="keyword">int</span>.class;</span><br><span class="line">    obj=<span class="keyword">double</span>.class;</span><br><span class="line">    obj=shapes.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个奇怪的用法是，当你使用这种泛型语法来构建你手头有的一个Class类的对象的基类对象时，必须采用以下的特殊语法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shapes</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">round</span> <span class="keyword">extends</span> <span class="title">shapes</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;round&gt; rclass = round.class;</span><br><span class="line">    Class&lt;? <span class="keyword">super</span> round&gt; sclass = rclass.getSuperClass();</span><br><span class="line"><span class="comment">//Class&lt;shapes&gt; sclass=rclass.getSuperClass(); 我们明知道，round的基类就是shapes，但是却不能直接声明 Class &lt; shapes &gt;，必须使用特殊语法 Class &lt; ? super round &gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>API</p><p><strong>getClassLoader**</strong>()**</p><p>获取该类的类装载器。</p><p><strong>getComponentType()</strong></p><p>如果当前类表示一个数组，则返回表示该数组组件的Class对象，否则返回null。</p><p><strong>getConstructor(Class[])</strong></p><p>返回当前Class对象表示的类的指定的公有构造子对象。</p><p><strong>getConstructors()</strong></p><p>返回当前Class对象表示的类的所有公有构造子对象数组。</p><p><strong>getDeclaredConstructor(Class[])</strong></p><p>返回当前Class对象表示的类的指定已说明的一个构造子对象。</p><p><strong>getDeclaredConstructors()</strong></p><p>返回当前Class对象表示的类的所有已说明的构造子对象数组。</p><p><strong>getDeclaredField(String)</strong></p><p>返回当前Class对象表示的类或接口的指定已说明的一个域对象。</p><p><strong>getDeclaredFields()</strong></p><p>返回当前Class对象表示的类或接口的所有已说明的域对象数组。</p><p><strong>getDeclaredMethod(String,Class[])</strong></p><p>返回当前Class对象表示的类或接口的指定已说明的一个方法对象。</p><p><strong>getDeclaredMethods()</strong></p><p>返回Class对象表示的类或接口的所有已说明的方法数组。</p><p><strong>getField(String)</strong></p><p>返回当前Class对象表示的类或接口的指定的公有成员域对象。</p><p><strong>getFields()</strong></p><p>返回当前Class对象表示的类或接口的所有可访问的公有域对象数组。</p><p><strong>getInterfaces()</strong></p><p>返回当前对象表示的类或接口实现的接口。</p><p><strong>getMethod(String,Class[])</strong></p><p>返回当前Class对象表示的类或接口的指定的公有成员方法对象。</p><p><strong>getMethods()</strong></p><p>返回当前Class对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。</p><p><strong>getModifiers()</strong></p><p>返回该类或接口的Java语言修改器代码。</p><p><strong>getName()</strong></p><p>返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。</p><p><strong>getResource(String)</strong></p><p>按指定名查找资源。</p><p><strong>getResourceAsStream(String)</strong></p><p>用给定名查找资源。</p><p><strong>getSigners()</strong></p><p>获取类标记。</p><p><strong>getSuperclass()</strong></p><p>如果此对象表示除Object外的任一类,那么返回此对象的父类对象。</p><p><strong>isArray()</strong></p><p>如果Class对象表示一个数组则返回true,否则返回false。</p><p><strong>isAssignableFrom(Class)</strong></p><p>判定Class对象表示的类或接口是否同参数指定的Class表示的类或接口相同，或是其父类。</p><p><strong>isInstance(Object)</strong></p><p>此方法是Java语言instanceof操作的动态等价方法。</p><p><strong>isInterface()</strong></p><p>判定指定的Class对象是否表示一个接口类型。</p><p><strong>isPrimitive()</strong></p><p>判定指定的Class对象是否表示一个Java的基类型。</p><p><strong>newInstance()</strong></p><p>创建类的新实例。</p><p><strong>toString()</strong></p><p>将对象转换为字符串。</p></blockquote><h1 id="4-Object类"><a href="#4-Object类" class="headerlink" title="4. Object类"></a>4. Object类</h1><blockquote><p><a href="http://ihenu.iteye.com/blog/2233249" target="_blank" rel="noopener">参考 a Javaer</a></p></blockquote><p>Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。</p><p>Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法，其中9个被所有子类继承</p><h2 id="4-1-public-Object"><a href="#4-1-public-Object" class="headerlink" title="4. 1 public Object();"></a>4. 1 public Object();</h2><blockquote><p>大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。</p><p>为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。</p><p>当然，并不是所有的类都是通过此种方式去构建，也自然的，并不是所有的类构造函数都是public。</p></blockquote><h2 id="4-2-private-static-native-void-registerNatives"><a href="#4-2-private-static-native-void-registerNatives" class="headerlink" title="4.2 private static native void registerNatives();"></a>4.2 <strong>private static native void registerNatives();</strong></h2><p>registerNatives函数前面有native关键字修饰<strong>，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。</strong></p><p>方法的具体实现体在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。</p><p>既然如此，可能有人会问，registerNatives()修饰符为private，且并没有执行，作用何以达到？其实，在Java源码中，此方法的声明后有紧接着一段静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line"></span><br><span class="line">   registerNatives();  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-protected-native-Object-clone-throws-CloneNotSupportedException"><a href="#4-3-protected-native-Object-clone-throws-CloneNotSupportedException" class="headerlink" title="4.3 protected native Object clone() throws CloneNotSupportedException;"></a>4.3 <strong>protected native Object clone() throws CloneNotSupportedException;</strong></h2><blockquote><p>看，clone()方法又是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone英文翻译为”克隆”。Java术语表述为：<strong>clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。</strong></p></blockquote><p>明白了clone的含义后，接下来看看如果调用clone()函数对象进行此克隆操作。</p><p>首先看一下下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.corn.objectsummary;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.corn.Person;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();  </span><br><span class="line">        <span class="comment">//下面代码出错 The method clone() from the type Object is not visible  </span></span><br><span class="line">        Object clone = o1.clone();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>回到Object类中clone()方法的定义，可以看到其被声明为protected，估计问题就在这上面了，<strong>protected修饰的属性或方法表示：在同一个包内或者不同包的子类可以访问。</strong>显然，Object类与ObjectTest类在不同的包中，但是ObjectTest继承自Object，是Object类的子类，于是，现在却出现子类中通过Object引用不能访问protected方法，原因在于对”不同包中的子类可以访问”没有正确理解。</p></blockquote><p>“不同包中的子类可以访问”，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外）</p><blockquote><p>下面代码因为此时的主调已经是子类的引用了，所以正常编译，但运行时会报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.corn.objectsummary;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        ObjectTest ot1 = <span class="keyword">new</span> ObjectTest();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ObjectTest ot2 = (ObjectTest) ot1.clone();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在运行过程中会抛出”java.lang.CloneNotSupportedException”,表明clone()方法并未正确执行完毕，问题的原因在与Java中的语法规定：</p><p><strong>clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。</strong></p><p><strong>clone方法实现的是浅拷贝，只拷贝当前对象，并且在堆中分配新的空间，放这个复制的对象。但是对象如果里面有其他类的子对象，那么就不会拷贝到新的对象中。</strong></p><p>深拷贝和浅拷贝的区别</p><blockquote><p>浅拷贝<br>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p>深拷贝<br>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p>现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的。</p></blockquote><h2 id="4-4-public-final-native-Class-lt-gt-getClass"><a href="#4-4-public-final-native-Class-lt-gt-getClass" class="headerlink" title="4.4 public final native Class&lt;?&gt; getClass();"></a>4.4 <strong>public final native Class&lt;?&gt; getClass();</strong></h2><p>getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。</p><blockquote><p>首先解释下”类对象”的概念：<strong>在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</strong></p></blockquote><h2 id="4-5-public-boolean-equals-Object-obj"><a href="#4-5-public-boolean-equals-Object-obj" class="headerlink" title="4.5 public boolean equals(Object obj);"></a>4.5 <strong>public boolean equals(Object obj);</strong></h2><p>==与equals在Java中经常被使用，大家也都知道==与equals的区别：</p><p>==表示的是变量值完全相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）；</p><p>equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。</p><p>实际上，上面说法是不严谨的，更多的只是常见于String类中。首先看一下Object类中关于equals()方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，Object原生的equals()方法内部调用的正是==，与==具有相同的含义。既然如此，为什么还要定义此equals()方法？</p><p>equlas()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？</p><blockquote><p>如上，在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到object基类。</p></blockquote><p>Java中的约定：重写equals()方法必须重写hasCode()方法。</p><h2 id="4-6-public-native-int-hashCode"><a href="#4-6-public-native-int-hashCode" class="headerlink" title="4.6 public native int hashCode();"></a>4.6 <strong>public native int hashCode();</strong></h2><p>hashCode()方法返回一个整形数值，表示该对象的哈希码值。</p><p>hashCode()具有如下约定：</p><p>1).在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致;</p><p>2)<strong>.如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等；</strong></p><p>3).<strong>反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等</strong>。</p><p>即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt; equals()相等 =&gt; hashCode()相等。因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等 =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。</p><h2 id="4-7-public-String-toString"><a href="#4-7-public-String-toString" class="headerlink" title="4.7 public String toString();"></a>4.7 <strong>public String toString();</strong></h2><p>toString()方法返回该对象的字符串表示。先看一下Object中的具体方法体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。</p><p>getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。</p><p>toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。</p><h2 id="4-8-4-12-wait-…-notify-…-notifyAll"><a href="#4-8-4-12-wait-…-notify-…-notifyAll" class="headerlink" title="4.8 - 4.12 wait(…)/notify(…)/notifyAll()"></a>4.8 - 4.12 wait(…)/notify(…)/notifyAll()</h2><p>wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。</p><p>wait(long timeout)/wait(long timeout, int nanos)：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notisfy()/notisfyAll()方法，或超过指定的超时时间量。</p><p>notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。</p><blockquote><p><strong>wait(…)/notify()|notifyAll()方法只能在同步代码块中才能使用。</strong></p></blockquote><p>为什么却是Object这个基类所具有的方法？原因在于理论上任何对象都可以视为线程同步中的监听器，且wait(…)/notify()|notifyAll()方法只能在同步代码块中才能使用。</p><blockquote><p>wait源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">     wait(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且wait(long timeout, int nanos)方法定义内部实质上也是通过调用wait(long timeout)完成。而wait(long timeout)是一个native方法。因此，wait(…)方法本质上都是native方式实现。</p><p>notify()/notifyAll()方法也都是native方法。</p><h2 id="4-13-protected-void-finalize"><a href="#4-13-protected-void-finalize" class="headerlink" title="4.13  protected void finalize();"></a>4.13 <strong>protected void finalize();</strong></h2><p>finalize方法主要与Java垃圾回收机制有关。首先我们看一下finalized方法在Object中的具体定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>我们发现Object类中finalize方法被定义成一个空方法，为什么要如此定义呢？finalize方法的调用时机是怎么样的呢？</p><blockquote><p>首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）</p></blockquote></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/post/11419.html" rel="next" title="Java基础11：Java泛型详解"><i class="fa fa-chevron-left"></i> Java基础11：Java泛型详解</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/post/37276.html" rel="prev" title="Java基础13：Java反射">Java基础13：Java反射<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/iverson.jpg" alt="Joe"><p class="site-author-name" itemprop="name">Joe</p><p class="site-description motion-element" itemprop="description">Write Once,Run Anywhere</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">69</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/joeshero" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Class类"><span class="nav-text">1. Class类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-获取Class对象"><span class="nav-text">2. 获取Class对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-生成目标类的实例"><span class="nav-text">3. 生成目标类的实例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Object类"><span class="nav-text">4. Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-public-Object"><span class="nav-text">4. 1 public Object();</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-private-static-native-void-registerNatives"><span class="nav-text">4.2 private static native void registerNatives();</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-protected-native-Object-clone-throws-CloneNotSupportedException"><span class="nav-text">4.3 protected native Object clone() throws CloneNotSupportedException;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-public-final-native-Class-lt-gt-getClass"><span class="nav-text">4.4 public final native Class&lt;?&gt; getClass();</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-public-boolean-equals-Object-obj"><span class="nav-text">4.5 public boolean equals(Object obj);</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-public-native-int-hashCode"><span class="nav-text">4.6 public native int hashCode();</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-public-String-toString"><span class="nav-text">4.7 public String toString();</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-4-12-wait-…-notify-…-notifyAll"><span class="nav-text">4.8 - 4.12 wait(…)/notify(…)/notifyAll()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-13-protected-void-finalize"><span class="nav-text">4.13 protected void finalize();</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Joe</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">109.4k</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共109.4k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!1,scale:.3},log:!1,tagMode:!1})</script></body></html>
[{"title":"Java基础18：多线程","date":"2018-11-18T08:11:01.000Z","path":"2018/11/18/Java基础18：多线程/","text":"1. 多线程 线程是一个独立执行的调用序列，同一个进程的线程在同一时刻共享一些系统资源（比如文件句柄等）也能访问同一个进程所创建的对象资源（内存资源）。java.lang.Thread对象负责统计和控制这种行为。 每个程序都至少拥有一个线程-即作为Java虚拟机(JVM)启动参数运行在主类main方法的线程。在Java虚拟机初始化过程中也可能启动其他的后台线程。这种线程的数目和种类因JVM的实现而异。然而所有用户级线程都是显式被构造并在主线程或者是其他用户线程中被启动。 为什么要使用多线程 发挥多核处理器的能力 如果只使用单线程，无法使用到全部的CPU资源，造成CPU资源的浪费。 获得更高的吞吐率 如果程序是单核的，等待I/O时，处理器将处于空闲状态 更好的编程模型 2. 线程状态 NEW RUNNABLE WAITING TIME_WAITING BLOCKED TERMINATED 3. 创建线程 继承Thread 实现Runnable 实现Callable(带返回值) 从线程池获取 继承Thread 123456789101112131415161718public class MyThread extends Thread &#123; private static int i = 0; @Override public void run() &#123; for (; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \" i\"); &#125; &#125; public static void main(String[] args) &#123; for (int j = 0; j &lt; 2; j++) &#123; new MyThread().start(); &#125; &#125;&#125; 输出： 123456Thread-1 iThread-0 iThread-1 iThread-0 iThread-0 iThread-1 i 实现Runnable 123456789public class MyThread implements Runnable&#123; //.......省略 public static void main(String[] args) &#123; for (int j = 0; j &lt; 2; j++) &#123; new Thread(new MyThread()).start(); &#125; &#125;&#125; 实现Callable(带返回值) 12345678910111213141516171819202122232425262728293031public class MyThread implements Callable&lt;Integer&gt; &#123; private int sum = 0; @Override public Integer call() throws Exception &#123; for (int i = 0; i &lt; 5; i++) &#123; sum += i; &#125; return sum; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //创建Callable对象 Callable&lt;Integer&gt; callable = new MyThread(); //创建FutureTask对象接收返回值 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(callable); for (int j = 0; j &lt; 2; j++) &#123; new Thread(ft).start(); &#125; System.out.println(ft.get()); &#125;&#125; 在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyThread对象，同时作为了Thread对象的target。 线程池获取线程 12345678910111213141516171819202122232425public class MyThread &#123; private static int sum = 0; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 2; i++) &#123; //每个线程对sum自增5次 executorService.execute(() -&gt;&#123; for (int j = 0; j &lt; 5; j++) &#123; sum += 1; &#125; &#125;); &#125; executorService.shutdown(); System.out.println(sum); &#125;&#125; 输出： 110 4. 启动线程要想实现多线程，需要重写run方法，并使用start方法启动线程。 当线程终止之后，是不能被重新启动的。在同一个Thread上调用多次start方法会抛出InvalidThreadStateException异常。 判断线程是否存活：isAlive方法 线程优先级：setPriority， getPriority方法 5. 线程中断 每个线程都有一个相关的Boolean类型的中断标识。在线程t上调用t.interrupt会将该线程的中断标识设为true，除非线程t正处于Object.wait,Thread.sleep,或者Thread.join,这些情况下interrupt调用会导致t上的这些操作抛出InterruptedException异常，但是t的中断标识会被设为false。 任何一个线程的中断状态都可以通过调用isInterrupted方法来得到。如果线程已经通过interrupt方法被中断，这个方法将会返回true。 但是如果调用了Thread.interrupted方法且中断标识还没有被重置，或者是线程处于wait，sleep，join过程中，调用isInterrupted方法将会抛出InterruptedException异常。 调用t.join()方法将会暂停执行调用线程，直到线程t执行完毕：当t.isAlive()方法返回false的时候调用t.join()将会直接返回(return)。 另一个带参数毫秒(millisecond)的join方法在被调用时，如果线程没能够在指定的时间内完成，调用线程将重新得到控制权。 因为isAlive方法的实现原理，所以在一个还没有启动的线程上调用join方法是没有任何意义的。同样的，试图在一个还没有创建的线程上调用join方法也是不明智的。 起初，Thread类还支持一些另外一些控制方法：suspend,resume,stop以及destroy。这几个方法已经被声明过期。其中destroy方法从来没有被实现，估计以后也不会。而通过使用等待/唤醒机制增加suspend和resume方法在安全性和可靠性的效果有所欠缺 Thread的静态方法 静态方法Thread类中的部分方法被设计为只适用于当前正在运行的线程（即调用Thread方法的线程）。为强调这点，这些方法都被声明为静态的。 Thread.currentThread方法会返回当前线程的引用，得到这个引用可以用来调用其他的非静态方法，比如Thread.currentThread().getPriority()会返回调用线程的优先级。 Thread.interrupted方法会清除当前线程的中断状态并返回前一个状态。（一个线程的中断状态是不允许被其他线程清除的） Thread.sleep(long msecs)方法会使得当前线程暂停执行至少msecs毫秒。 Thread.yield方法纯粹只是建议Java虚拟机对其他已经处于就绪状态的线程（如果有的话）调度执行，而不是当前线程。最终Java虚拟机如何去实现这种行为就完全看其喜好了。 6. 线程通信利用wait，notify，join，CyclicBarrier，CountdownLatch等方法 具体见之后博客。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础17：clone与深拷贝，浅拷贝","date":"2018-11-16T11:52:50.000Z","path":"2018/11/16/Java基础17：clone与深拷贝，浅拷贝/","text":"在Java中，实现拷贝需要实现Cloneable接口，否则会报CloneNotSupportedException错误。 对于深浅拷贝，看一个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.project.liangyou;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * Created by Joe */public class Demo implements Cloneable &#123; public Demo() &#123; &#125; private String name; private int age; private Car car; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Demo&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", car=\" + car + '&#125;'; &#125; public static void main(String[] args) throws CloneNotSupportedException &#123; //1.new 对象 Demo demo1 = new Demo(); demo1.setAge(18); Car car = new Car(\"奥迪\", 123); demo1.setName(\"new一个对象\"); demo1.setCar(car); Demo demo2 = (Demo) demo1.clone(); System.out.println(demo2); demo1.setAge(100); demo1.setName(\"clone浅赋\"); car.name = \"奔驰\"; System.out.println(demo2); &#125;&#125;class Car &#123; String name; double price; public Car(String name, double price) &#123; this.name = name; this.price = price; &#125; @Override public String toString() &#123; return \"Car&#123;\" + \"name='\" + name + '\\'' + \", price=\" + price + '&#125;'; &#125;&#125; 输出 12Demo&#123;name='new一个对象', age=18, car=Car&#123;name='奥迪', price=123.0&#125;&#125;Demo&#123;name='new一个对象', age=18, car=Car&#123;name='奔驰', price=123.0&#125;&#125; 对于对象demo1，克隆一个对象demo2，并打印demo2，当再次修改demo1的值，demo2的值也会变，似乎二者共用了某些变量。 实际上，对于基本变量，demo2直接复制了一份来用，所以修改demo1的基本变量不会影响demo2的值。而对于引用变量，二者共用同一个引用变量。对于clone来说，这是一个浅拷贝。 若要实现深拷贝，需要自己重写clone方法，如 1234@Overrideprotected Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合7：HashSet,TreeSet与LinkedHashSet","date":"2018-11-15T13:38:05.000Z","path":"2018/11/15/Java集合7：HashSet-TreeSet与LinkedHashSet/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合6：TreeMap","date":"2018-11-15T13:36:43.000Z","path":"2018/11/15/Java集合6：TreeMap/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合5：LinkedHashMap与LRU","date":"2018-11-15T13:36:18.000Z","path":"2018/11/15/Java集合5：LinkedHashMap与LRU/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合4：HashMap与HashTable","date":"2018-11-15T13:35:05.000Z","path":"2018/11/15/Java集合4：HashMap与HashTable/","text":"1. Map 基于JDK1.8 Java 为数据结构中的映射定义了一个接口 java.util.Map，此接口主要有四个常用的实现类，分别是 HashMap、Hashtable、LinkedHashMap 和 TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： HashMap：它根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。 Hashtable：Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 LinkedHashMap：LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 TreeMap：TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。 对于上述四种 Map 类型的类，要求映射中的 key 是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map 对象很可能就定位不到映射的位置了。 2. HashMap查找O(1),添加O(1)，最坏 O(n)允许null值 2.1 成员变量继承接口 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 初始容量（2^4^ = 16） 1static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; 最大容量(2^30^) 1static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 默认负载因子0.75 1static final float DEFAULT_LOAD_FACTOR = 0.75f; 转换为红黑树阈值为8（当一个桶中链表大于8转换为红黑树） 1static final int TREEIFY_THRESHOLD = 8; 由红黑树退化为链表阈值为6 1static final int UNTREEIFY_THRESHOLD = 6; 所能容纳key-value对最大个数（threshold = length * Load factor） 1int threshold; modCount 字段主要用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。 1int modCount; JDK1.8中，HashMap由数组+链表+红黑树实现（JDK1.8 增加了红黑树部分） 123456789101112131415//Node结构static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个 node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node 是 HashMap 的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射 (键值对)。上图中的每个黑色圆点就是一个 Node 对象。 2.2 解决冲突2) HashMap 就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java 中 HashMap 采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： 1map.put(\"Joe\",\"Hero\"); 系统将调用”Joe”这个 key 的 hashCode() 方法得到其 hashCode 值（该方法适用于每个 Java 对象），然后再通过 Hash 算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个 key 会定位到相同的位置，表示发生了 Hash 碰撞。当然 Hash 算法计算结果越分散均匀，Hash 碰撞的概率就越小，map 的存取效率就会越高。 如果哈希桶数组很大，即使较差的 Hash 算法也会比较分散，如果哈希桶数组数组很小，即使好的 Hash 算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的 hash 算法减少 Hash 碰撞。那么通过什么方式来控制 map 使得 Hash 碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的 Hash 算法和扩容机制。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合3：Iterator,fail-fast机制与比较器","date":"2018-11-15T13:34:28.000Z","path":"2018/11/15/Java集合3：Iterator-fail-fast机制与比较器/","text":"1. Iterator迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。 12345Iterator iterator = list.iterator(); while(iterator.hasNext())&#123; String string = iterator.next(); //do something &#125; 对于数组我们是使用下标来进行处理的 12345int[] arrays = new int[10]; for(int i = 0 ; i &lt; arrays.length ; i++)&#123; int a = arrays[i]; //do something &#125; 对于ArrayList是这么处理的 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i = 0 ; i &lt; list.size() ; i++)&#123; String string = list.get(i); //do something &#125; 对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。 在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。 使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。 java.util.Iterator在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同： 1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。 2、方法名称得到了改进。 12345public interface Iterator &#123; boolean hasNext(); Object next(); void remove();&#125; Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型 boolean hasNext()：判断容器内是否还有可供访问的元素 void remove()：删除迭代器刚越过的元素 前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。 Iterator的实现以ArrayList为例 12345public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;Itr() &#123;&#125; 可以看出，iterator中构造了一个对象Itr。Itr是一个内部类。 12345private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; &#125; 其中定义了三个变量 123int cursor; // index of next element to returnint lastRet = -1; // index of last element returned; -1 if no suchint expectedModCount = modCount; 其中expectedModCount用于fast-fail。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置&gt; 123public boolean hasNext() &#123; return cursor != size;&#125; hasNext方法就是判断下一个元素索引是否为size。 123456789101112@SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor;//记录索引位置 if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; checkForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。 1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; remove方法 2. fail-fast与fail-safefail-fast “快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。 记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException异常，从而产生fail-fast机制。 注意这里的异常抛出条件是检测到modCount != exceptModCount这个条件。这个异常只建议用于检查并发修改的bug。 场景： java.util 包下的集合类都是快速失败的， 不能在多线程下发生并发修改（迭代过程中被修改） 。 fail-safe 采用安全失败机制的集合容器， 在遍历时不是直接在集合内容上访问的， 而是先复制原有集合内容， 在拷贝的集合上进行遍历。原理： 由于迭代时是对原集合的拷贝进行遍历， 所以在遍历过程中对原集合所作的修改并不能被迭代器检测到， 所以不会触发 Concurrent Modification Exception。缺点： 基于拷贝内容的优点是避免了 Concurrent Modification Exception， 但同样地，迭代器并不能访问到修改后的内容， 即： 迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。场景： java.util.concurrent 包下的容器都是安全失败， 可以在多线程下并发使用， 并发修改。 快速失败和安全失败是对迭代器而言的。 快速失败： 当在迭代一个集合的时候， 如果有另外一个线程在修改这个集合， 就会抛出 ConcurrentModification 异常， java.util 下都是快速失败。 安全失败： 在迭代时候会在集合二层做一个拷贝， 所以在修改集合上层元素不会影响下层。 在 java.util.concurrent 下都是安全失败 3. Comparator和ComparableJava 中为我们提供了两种比较机制：Comparable 和 Comparator。 Comparable内排序，Comparable 在 java.lang包下，是一个接口，内部只有一个方法 compareTo()： 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; Comparable 可以让实现它的类的对象进行比较，具体的比较规则是按照 compareTo 方法中的规则进行。这种顺序称为 自然顺序。 compareTo 方法的返回值有三种情况： 123e1.compareTo(e2) &gt; 0 即 e1 &gt; e2e1.compareTo(e2) = 0 即 e1 = e2e1.compareTo(e2) &lt; 0 即 e1 &lt; e2 Comparator外排序，Comparable 接口属于 Java 集合框架的一部分。 Comparator 定制排序 Comparator 在 java.util 包下，也是一个接口，JDK 1.8 以前只有两个方法： 123456public interface Comparator&lt;T&gt; &#123; public int compare(T lhs, T rhs); public boolean equals(Object object);&#125; 4. 测试测试Comparable 1234567891011121314public class Apple implements Comparable&lt;Apple&gt;&#123; private double price; private double weight; //省略get，set方法，重写toString()方法 @Override public int compareTo(Apple o)&#123; //按照价格由小到大排序 if(this.getPrice() - o.getPrice() &gt; 0)&#123; return 1; &#125;else if(this.getPrice() - o.getPrice() == 0)&#123; return 0; &#125;else return -1; &#125;&#125; 123456789public static void main(String[] args) &#123; List&lt;Apple&gt; apples = Arrays.asList(new Apple(25, 5), new Apple(12, 25), new Apple(20,18)); Collections.sort(apples); for (Apple apple : apples) &#123; System.out.println(apple); &#125;&#125; 输出 123Apple&#123;weight=25.0, price=5.0&#125;Apple&#123;weight=20.0, price=18.0&#125;Apple&#123;weight=12.0, price=25.0&#125; 测试Comparator 自定义比较器 12345678910111213class MyComparator implements Comparator&lt;Apple&gt; &#123; @Override public int compare(Apple o1, Apple o2) &#123; if (o1.getPrice() - o2.getPrice() &gt; 0) &#123; return 1; &#125; else if (o1.getPrice() - o2.getPrice() == 0) &#123; return 0; &#125;else &#123; return -1; &#125; &#125;&#125; 123456public static void main(String[] args) &#123; Apple a1 = new Apple(25, 5); Apple a2 = new Apple(10, 12); MyComparator comparator = new MyComparator(); System.out.println(comparator.compare(a1,a2));&#125; 输出： -1","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合2：LinkedList与Queue","date":"2018-11-15T13:33:41.000Z","path":"2018/11/15/Java集合2：LinkedList与Queue/","text":"1. LinkedList 基于JDK1.8 LinkedList与ArrayList一样，实现了List接口 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList底层基于双向链表实现。 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; [ 关 注 点 结 论 LinkedList是否允许空 允许 LinkedList是否允许重复数据 允许 LinkedList是否有序 有序 LinkedList是否线程安全 非线程安全 LinkedList定义了三个变量 12345transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; 构造方法 LinkedList有两个构造方法 12345678//构造一个空列表public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 带参构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//addAll方法public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //检查下标，若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常 checkPositionIndex(index); //转换为数组 Object[] a = c.toArray(); //插入元素的个数 int numNew = a.length; //个数为0返回false if (numNew == 0) return false; Node&lt;E&gt; pred, succ; //如果添加处为list尾部，直接将pred指向last //否则保存index节点，pred指向它之前一个节点 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; //遍历添加节点 for (Object o : a) &#123; //类型转换 @SuppressWarnings(\"unchecked\") E e = (E) o; //构造新节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果为空列表，first指向新节点 //否则尾插法 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //如果succ为null，即在list尾部添加了元素，需要改变last //否则就是在list中间插入，将succ保存的index处节点放入 if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; //修改元素个数 size += numNew; //modCount++，用于快速失败 modCount++; return true;&#125; add方法 1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 123456789public void add(int index, E element) &#123; //检查下标 checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 调用了linkLast方法和linkBefore方法。 linkLast方法，在List尾部添加元素 1234567891011void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; linkBefore方法 123456789101112void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 具体实现步骤和之前addAll方法类似 remove方法 1234567891011121314151617181920public boolean remove(Object o) &#123; //首先判断o是否为null,是的话遍历list找到null修改指针 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; //不是的话遍历list找到o，调用unlink方法修改前后指针 &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; unlink方法修改前后指针 123456789101112131415161718192021222324252627282930E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; //x之后节点 final Node&lt;E&gt; next = x.next; //x之前节点 final Node&lt;E&gt; prev = x.prev; //prev为null，表示x为头节点，直接将头节点置为next if (prev == null) &#123; first = next; //否则prev.next = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; //next为null表示x为尾节点，直接last = prev; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 2. Queue Deque：双向队列 PriorityQueue：优先级队列，底层为数组实现的堆","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合1：ArrayList,Vector与Stack","date":"2018-11-15T13:33:04.000Z","path":"2018/11/15/Java集合1：ArrayList-Vector与Stack/","text":"1. ArrayList JDK1.8 ArrayList是基于动态数组实现的，它实现了List接口，Cloneable接口等。 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 所谓动态，就是说它的大小可变。它的底层是一个Object[]数组。 1transient Object[] elementData; 至于用关键字transient修饰，表示这个数组不能被序列化，它重写了clone方法来实现序列化，避免了数组只有少量元素却需要全部序列化造成的浪费。（序列化速度，序列化之后文件大小） 关注点 结论 是否允许空（null） 允许 是否允许重复元素 允许 是否有序 有序 是否线程安全 非线程安全 ArrayList使用了一个私有变量来表示数组大小 1private int size; 初始容量 ArrayList初始容量为10，如果没有传入参数，默认为空数组，并将在add操作时扩容数组容量为10，如果传入参数，将直接构造数组。 1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 1.1 增ArrayList有两个add方法，可以在数组最后和数组中间插入元素。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 此方法在数组最后添加元素。首先ensureCapacityInternal()方法确保没有溢出，溢出就扩容。之后在数组末尾添加元素。 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index);//判断索引是否合法 ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 在数组任意位置添加元素。首先检查index是否合法，其次，调用ensureCapacityInternal()方法。之后，调用System.arraycopy方法将elementData数组的index及之后的部分复制到自己的index+1位置，就是将index之后的部分向后移动一位，再将element插入到index位置。 1.2 删ArrayList支持两种删除方式 按照下标删除 按照元素删除，这会删除ArrayList中第一个匹配的元素。 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 按照下标删除。首先检查下标。之后，将index之后的元素利用System.arraycopy()方法向左移动一位，并将elementData最后一位置为null，让GC回收它。 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 按照元素删除。删除第一个匹配的元素。 123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 清空ArrayList。将所有元素置空。 1.3 改1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 检查下标并替换。 1.4 查123456public E get(int index) &#123; //检查下标 rangeCheck(index); return elementData(index);&#125; 检查下标，返回index的值。 1.5 modCount机制由以上代码可以看出，在一个迭代器初始的时候会赋予它调用这个迭代器的对象的mCount，如果在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样那就抛异常 。Fail-Fast 机制 我们知道 java.util.ArrayList 不是线程安全的，ArrayList，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。 这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对ArrayList 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。 在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 ArrayList。 所以，当遍历那些非线程安全的数据结构时，尽量使用迭代器 1.6 扩容扩容时机发生在add时，如果当前elementData容量小于size，会发生扩容。 1234567891011121314//minCapacity = size + 1;预期大小private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //预期大小大于容量，发生扩容 if (minCapacity - elementData.length &gt; 0) //grow()方法扩容 grow(minCapacity);&#125; 可以看到，grow方法才真正实现了扩容。 12345678910111213private void grow(int minCapacity) &#123; // overflow-conscious code //保存旧容量 int oldCapacity = elementData.length; //扩容1.5倍，位运算提高效率 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 对于扩容1.5倍，是一个经验值，扩容太大会造成资源浪费，太小可能会造成频繁扩容。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。 12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 如果数组大小容量确定，可以是使用trimToSize()方法将底层数组的容量调整为当前列表保存的实际元素的大小。 1.7 线程安全ArrayList默认线程非安全。在其迭代器iteator中，如果有多线程操作导致modcount改变，会执行fastfail。抛出异常。 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 可以使用Collections.synchronizedList()方法将其变为线程安全的。（底层加synchronized锁） 1List list = Collections.synchronizedList(new ArrayList(...)); 2. Vector123public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable Vector与ArrayList类似，不过elementData数组不用transient修饰 1protected Object[] elementData; 主要理解以下它与ArrayList的不同之处。 2.1 初始容量及扩容123public Vector() &#123; this(10);&#125; 默认初始容量为10。 与ArrayList不同的构造函数 12345678public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125; 其中，initialCapacity指定初始容量，capacityIncrement指定扩容中数组增加的大小。 12345678910111213private void grow(int minCapacity) &#123; // overflow-conscious code //原始容量 int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 2.2 线程安全Vector大部分方法都使用了synchronized修饰符，所以他是线层安全的集合类。 3. Stack在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。 常用方法 empty() 测试堆栈是否为空。 peek() 查看堆栈顶部的对象，但不从堆栈中移除它。 pop() 移除堆栈顶部的对象，并作为此函数的值返回该对象。 push(E item) 把项压入堆栈顶部。 search(Object o) 返回对象在堆栈中的位置，以 1 为基数。 Stack继承Vector，他对Vector进行了简单的扩展： 12publicclass Stack&lt;E&gt; extends Vector&lt;E&gt; Stack利用 synchronized实现线程安全。 4. ArrayList优缺点ArrayList优缺点： 底层以数组实现，实现了RandomAccess接口，对于随机访问特别快。（O(1)） ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已 缺点： 删除，插入元素时涉及到部分数组元素的复制，当元素较多时比较耗费性能。（O(n)） 因此，ArrayList比较适合顺序添加、随机访问的场景。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java8新特性","date":"2018-11-15T13:25:23.000Z","path":"2018/11/15/Java8新特性/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java创建对象的四种方式","date":"2018-11-15T07:27:29.000Z","path":"2018/11/15/Java创建对象的四种方式/","text":"new 关键字 clone（浅拷贝），需要实现Clonable接口 反序列化 需要实现Serializable接口 反射(2种) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * Created by Joe */public class Demo implements Cloneable,Serializable &#123; private static final long serialVersionUID = 1L; public Demo() &#123; &#125; private String name = \"joe\"; public void print() &#123; System.out.println(this.name ); &#125; public void setName(String name) &#123; this.name = name; &#125; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, CloneNotSupportedException, IOException, ClassNotFoundException &#123; //1.new 对象 Demo demo1 = new Demo(); demo1.setName(\"new一个对象\"); demo1.print(); //2.反射 Class对象的new Instance()方法 Class&lt;Demo&gt; clazz = Demo.class; Demo demo2 = clazz.newInstance(); demo2.setName(\"反射 Class对象创建实例对象\"); demo2.print(); //3.反射 Class对象获取Constructor对象，再使用Constructor对象的newInstance方法。 Class&lt;Demo&gt; c = Demo.class; Constructor&lt;Demo&gt; constructor = c.getConstructor(); Demo demo3 = constructor.newInstance(); demo3.setName(\"反射 Constructor创建一个对象\"); demo3.print(); //4.clone Demo demo4 = (Demo) demo3.clone(); demo4.setName(\"clone 创建对象\"); demo4.print(); //5.反序列化 ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"D:\\\\aaa.txt\")); outputStream.writeObject(demo3); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"D:\\\\aaa.txt\")); Demo demo5 = (Demo) inputStream.readObject(); demo5.setName(\"反序列化创建对象\"); demo5.print(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"demo","slug":"demo","permalink":"http://yoursite.com/tags/demo/"}]},{"title":"一个关于Java死锁的例子","date":"2018-11-08T16:31:53.000Z","path":"2018/11/09/一个关于Java死锁的例子/","text":"1. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Created by Joe */public class Demo &#123; public static Integer a; public static Integer b; static &#123; a = 1; b = 2; &#125; static class demo1 implements Runnable &#123; @Override public void run() &#123; synchronized (a) &#123; System.out.println(\"get a wait b\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (b) &#123; System.out.println(\"get a and b\"); &#125; &#125; &#125; &#125; static class demo2 implements Runnable &#123; @Override public void run() &#123; synchronized (b) &#123; System.out.println(\"get b wait a\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (a) &#123; System.out.println(\"get a and b\"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Thread(new demo1()).start(); new Thread(new demo2()).start(); &#125;&#125; 2. 输出12get a wait bget b wait a","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"demo","slug":"demo","permalink":"http://yoursite.com/tags/demo/"}]},{"title":"Java基础16：Java序列化和反序列化","date":"2018-11-07T16:52:47.000Z","path":"2018/11/08/Java基础16：Java序列化和反序列化/","text":"1. 序列化与反序列化 部分转自 Hollis 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。 2. Java对象的序列化与反序列化在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些Java对象都是存在于JVM的堆内存中的。只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。 但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。 对象序列化机制（object serialization）是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。 在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。 3. 相关接口及类Java为了方便开发人员将Java对象进行序列化及反序列化提供了一套方便的API来支持。其中包括以下接口和类： java.io.Serializable java.io.Externalizable ObjectOutput ObjectInput ObjectOutputStream ObjectInputStream 4. Serializable 接口类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。 当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 NotSerializableException。 如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成java.io.Serializable接口。 下面是一个实现了java.io.Serializable接口的类 1234567891011121314151617181920212223242526272829303132333435package com.hollischaung.serialization.SerializableDemos;import java.io.Serializable;/** * Created by hollis on 16/2/17. * 实现Serializable接口 */public class User1 implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 通过下面的代码进行序列化及反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hollischaung.serialization.SerializableDemos;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import java.io.*;/** * SerializableDemo1 结合SerializableDemo2说明 一个类要想被序列化必须实现Serializable接口 */public class SerializableDemo1 &#123; public static void main(String[] args) &#123; //Initializes The Object User1 user = new User1(); user.setName(\"hollis\"); user.setAge(23); System.out.println(user); //Write Obj to File ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(\"tempFile\")); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(oos); &#125; //Read Obj from File File file = new File(\"tempFile\"); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); User1 newUser = (User1) ois.readObject(); System.out.println(newUser); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(ois); try &#123; FileUtils.forceDelete(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//OutPut://User&#123;name='hollis', age=23&#125;//User&#123;name='hollis', age=23&#125; 5. Externalizable接口除了Serializable 之外，java中还提供了另一个序列化接口Externalizable 为了了解Externalizable接口和Serializable接口的区别，先来看代码，我们把上面的代码改成使用Externalizable的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hollischaung.serialization.ExternalizableDemos;import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput;/** * Created by hollis on 16/2/17. * 实现Externalizable接口 */public class User1 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 12345678910111213141516171819202122232425262728package com.hollischaung.serialization.ExternalizableDemos;import java.io.*;/** * Created by hollis on 16/2/17. */public class ExternalizableDemo1 &#123; //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //IOException直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"tempFile\")); User1 user = new User1(); user.setName(\"hollis\"); user.setAge(23); oos.writeObject(user); //Read Obj from file File file = new File(\"tempFile\"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); User1 newInstance = (User1) ois.readObject(); //output System.out.println(newInstance); &#125;&#125;//OutPut://User&#123;name='null', age=0&#125; 通过上面的实例可以发现，对User1类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态并没有被持久化下来。这就是Externalizable接口和Serializable接口的区别： Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。 按照要求修改之后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hollischaung.serialization.ExternalizableDemos;import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput;/** * Created by hollis on 16/2/17. * 实现Externalizable接口,并实现writeExternal和readExternal方法 */public class User2 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(name); out.writeInt(age); &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = (String) in.readObject(); age = in.readInt(); &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 12345678910111213141516171819202122232425package com.hollischaung.serialization.ExternalizableDemos;import java.io.*;public class ExternalizableDemo2 &#123; //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //IOException直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"tempFile\")); User2 user = new User2(); user.setName(\"hollis\"); user.setAge(23); oos.writeObject(user); //Read Obj from file File file = new File(\"tempFile\"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); User2 newInstance = (User2) ois.readObject(); //output System.out.println(newInstance); &#125;&#125;//OutPut://User&#123;name='hollis', age=23&#125; 这次，就可以把之前的对象状态持久化下来了。 如果User类中没有无参数的构造函数，在运行时会抛出异常：java.io.InvalidClassException 6. ObjectOutput和ObjectInput 接口ObjectInput接口 扩展自 DataInput 接口以包含对象的读操作。 DataInput 接口用于从二进制流中读取字节，并根据所有 Java 基本类型数据进行重构。同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具。 对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (end of file)，则将抛出 EOFException（IOException 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 IOException 而不是 EOFException。尤其是，在输入流已关闭的情况下，将抛出 IOException。 ObjectOutput 扩展 DataOutput 接口以包含对象的写入操作。 DataOutput 接口用于将数据从任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具。 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException。 7. ObjectOutputStream类和ObjectInputStream类通过前面的代码片段中我们也能知道，我们一般使用ObjectOutputStream的writeObject方法把一个对象进行持久化。再使用ObjectInputStream的readObject从持久化存储中把对象读取出来。 8. Transient 关键字Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 9. 序列化ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID) 序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。 10. 静态变量不参与序列化12345678910111213141516171819202122232425public class Test implements Serializable &#123; private static final long serialVersionUID = 1L; public static int staticVar = 5; public static void main(String[] args) &#123; try &#123; //初始时staticVar为5 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"result.obj\")); out.writeObject(new Test()); out.close(); //序列化后修改为10 Test.staticVar = 10; ObjectInputStream oin = new ObjectInputStream(new FileInputStream(\"result.obj\")); Test t = (Test) oin.readObject(); oin.close(); //再读取，通过t.staticVar打印新的值 System.out.println(t.staticVar); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。 11. 探究ArrayList的序列化 ArrayList的序列化在介绍ArrayList序列化之前，先来考虑一个问题： 如何自定义的序列化和反序列化策略 带着这个问题，我们来看java.util.ArrayList的源码 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; private static final long serialVersionUID = 8683452581122892189L; transient Object[] elementData; // non-private to simplify nested class access private int size; &#125; 从上面的代码中可以知道ArrayList实现了java.io.Serializable接口，那么我们就可以对它进行序列化及反序列化。 因为elementData是transient的，所以我们认为这个成员变量不会被序列化而保留下来。我们写一个Demo，验证一下我们的想法： 1234567891011121314public class ArrayList的序列化 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ArrayList list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"arr\")); objectOutputStream.writeObject(list); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"arr\")); ArrayList list1 = (ArrayList) objectInputStream.readObject(); objectInputStream.close(); System.out.println(Arrays.toString(list.toArray())); //序列化成功，里面的元素保持不变。 &#125; 了解ArrayList的人都知道，ArrayList底层是通过数组实现的。那么数组elementData其实就是用来保存列表中的元素的。通过该属性的声明方式我们知道，他是无法通过序列化持久化下来的。那么为什么code4的结果却通过序列化和反序列化把List中的元素保留下来了呢？ 在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。 如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。 用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。 1234567891011121314151617181920212223private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 那么为什么ArrayList要用这种方式来实现序列化呢？ why transient ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。 why writeObject and readObject 前面说过，为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList使用transient来声明elementData。 但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写writeObject 和 readObject方法的方式把其中的元素保留下来。 12. 自定义的序列化和反序列化策略 通过在被序列化的类中增加writeObject 和 readObject方法","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础15：Java IO","date":"2018-11-07T16:51:48.000Z","path":"2018/11/08/Java基础15：Java-IO/","text":"一、概览Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO 二、磁盘操作File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 递归地列出一个目录下所有文件： 123456789101112public static void listAllFiles(File dir) &#123; if (dir == null || !dir.exists()) &#123; return; &#125; if (dir.isFile()) &#123; System.out.println(dir.getName()); return; &#125; for (File file : dir.listFiles()) &#123; listAllFiles(file); &#125;&#125; 三、字节操作实现文件复制1234567891011121314151617public static void copyFile(String src, String dist) throws IOException &#123; FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20 * 1024]; int cnt; // read() 最多读取 buffer.length 个字节 // 返回的是实际读取的个数 // 返回 -1 的时候表示读到 eof，即文件尾 while ((cnt = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, cnt); &#125; in.close(); out.close();&#125; 装饰者模式Java I/O 使用了装饰者模式来实现。以 InputStream 为例， InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。 12FileInputStream fileInputStream = new FileInputStream(filePath);BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。 四、字符操作编码与解码编码就是把字符转换为字节，而解码是把字节重新组合成字符。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。 Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。 String 的编码方式String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。 1234String str1 = \"中文\";byte[] bytes = str1.getBytes(\"UTF-8\");String str2 = new String(bytes, \"UTF-8\");System.out.println(str2); 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。 1byte[] bytes = str1.getBytes(); Reader 与 Writer不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从字节流解码成字符流； OutputStreamWriter 实现字符流编码成为字节流。 实现逐行输出文本文件的内容123456789101112131415public static void readFileContent(String filePath) throws IOException &#123; FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close();&#125; 五、对象操作序列化序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。 Serializable序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException, ClassNotFoundException &#123; A a1 = new A(123, \"abc\"); String objectFile = \"file/a1\"; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile)); objectOutputStream.writeObject(a1); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile)); A a2 = (A) objectInputStream.readObject(); objectInputStream.close(); System.out.println(a2);&#125;private static class A implements Serializable &#123; private int x; private String y; A(int x, String y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"x = \" + x + \" \" + \"y = \" + y; &#125;&#125; transienttransient 关键字可以使一些属性不会被序列化。 ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。 1private transient Object[] elementData; 六、网络操作Java 中的网络支持： InetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 InetAddress没有公有的构造函数，只能通过静态方法来创建实例。 12InetAddress.getByName(String host);InetAddress.getByAddress(byte[] address); URL可以直接从 URL 中读取字节流数据。 1234567891011121314151617181920public static void main(String[] args) throws IOException &#123; URL url = new URL(\"http://www.baidu.com\"); /* 字节流 */ InputStream is = url.openStream(); /* 字符流 */ InputStreamReader isr = new InputStreamReader(is, \"utf-8\"); /* 提供缓存功能 */ BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; br.close();&#125; SocketsServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 Datagram DatagramSocket：通信类 DatagramPacket：数据包类 七、NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。 流与块I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。 面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。 通道与缓冲区1. 通道通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。 通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。 通道包括以下类型： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 2. 缓冲区 发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区包括以下类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区状态变量capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 状态变量的改变过程举例： ① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。 ② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。 ③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 ④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 ⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。 文件 NIO 实例以下展示了使用 NIO 快速复制文件的实例： 12345678910111213141516171819202122232425262728293031323334353637public static void fastCopy(String src, String dist) throws IOException &#123; /* 获得源文件的输入字节流 */ FileInputStream fin = new FileInputStream(src); /* 获取输入字节流的文件通道 */ FileChannel fcin = fin.getChannel(); /* 获取目标文件的输出字节流 */ FileOutputStream fout = new FileOutputStream(dist); /* 获取输出字节流的文件通道 */ FileChannel fcout = fout.getChannel(); /* 为缓冲区分配 1024 个字节 */ ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while (true) &#123; /* 从输入通道中读取数据到缓冲区中 */ int r = fcin.read(buffer); /* read() 返回 -1 表示 EOF */ if (r == -1) &#123; break; &#125; /* 切换读写 */ buffer.flip(); /* 把缓冲区的内容写入输出文件中 */ fcout.write(buffer); /* 清空缓冲区 */ buffer.clear(); &#125;&#125; 选择器NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。 应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。 1. 创建选择器1Selector selector = Selector.open(); 2. 将通道注册到选择器上123ServerSocketChannel ssChannel = ServerSocketChannel.open();ssChannel.configureBlocking(false);ssChannel.register(selector, SelectionKey.OP_ACCEPT); 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 它们在 SelectionKey 的定义如下： 1234public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4; 可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如： 1int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 3. 监听事件1int num = selector.select(); 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 4. 获取到达的事件1234567891011Set&lt;SelectionKey&gt; keys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove();&#125; 5. 事件循环因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 1234567891011121314while (true) &#123; int num = selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove(); &#125;&#125; 套接字 NIO 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class NIOServer &#123; public static void main(String[] args) throws IOException &#123; Selector selector = Selector.open(); ServerSocketChannel ssChannel = ServerSocketChannel.open(); ssChannel.configureBlocking(false); ssChannel.register(selector, SelectionKey.OP_ACCEPT); ServerSocket serverSocket = ssChannel.socket(); InetSocketAddress address = new InetSocketAddress(\"127.0.0.1\", 8888); serverSocket.bind(address); while (true) &#123; selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel(); // 服务器会为每个新连接创建一个 SocketChannel SocketChannel sChannel = ssChannel1.accept(); sChannel.configureBlocking(false); // 这个新连接主要用于从客户端读取数据 sChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; SocketChannel sChannel = (SocketChannel) key.channel(); System.out.println(readDataFromSocketChannel(sChannel)); sChannel.close(); &#125; keyIterator.remove(); &#125; &#125; &#125; private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); StringBuilder data = new StringBuilder(); while (true) &#123; buffer.clear(); int n = sChannel.read(buffer); if (n == -1) &#123; break; &#125; buffer.flip(); int limit = buffer.limit(); char[] dst = new char[limit]; for (int i = 0; i &lt; limit; i++) &#123; dst[i] = (char) buffer.get(i); &#125; data.append(dst); buffer.clear(); &#125; return data.toString(); &#125;&#125; 12345678910public class NIOClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\", 8888); OutputStream out = socket.getOutputStream(); String s = \"hello world\"; out.write(s.getBytes()); out.close(); &#125;&#125; 内存映射文件内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。 向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。 下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。 1MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024); 对比NIO 与普通 I/O 的区别主要有以下两点： NIO 是非阻塞的； NIO 面向块，I/O 面向流。 八、参考资料 Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002. IBM: NIO 入门 Java NIO Tutorial Java NIO 浅析 IBM: 深入分析 Java I/O 的工作机制 IBM: 深入分析 Java 中的中文编码问题 IBM: Java 序列化的高级认识 NIO 与传统 IO 的区别 Decorator Design Pattern Socket Multicast 转自 CyC2018","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础14：Java枚举类","date":"2018-11-07T16:51:16.000Z","path":"2018/11/08/Java基础14：Java枚举类/","text":"1. 定义枚举（enum）类型是Java 5新增的特性，它是一种新的类型，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。 在JDK1.5 之前，我们定义常量都是： public static final…. 。现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。 在程序设计中，有时会用到由若干个有限数据元素组成的集合，如一周内的星期一到星期日七个数据元素组成的集合，由三种颜色红、黄、绿组成的集合，一个工作班组内十个职工组成的集合等等，程序中某个变量取值仅限于集合中的元素。此时，可将这些数据集合定义为枚举类型。 因此，枚举类型是某类数据可能取值的集合，如一周内星期可能取值的集合为： { Sun,Mon,Tue,Wed,Thu,Fri,Sat} 该集合可定义为描述星期的枚举类型，该枚举类型共有七个元素，因而用枚举类型定义的枚举变量只能取集合中的某一元素值。由于枚举类型是导出数据类型，因此，必须先定义枚举类型，然后再用枚举类型定义枚举型变量。 枚举类型的基本结构 12enum &lt;枚举类型名&gt; &#123; &lt;枚举元素表&gt; &#125;; 如： 12enum weekdays &#123; Sun,Mon,Tue,Wed,Thu,Fri,Sat &#125;; 在编译器编译程序时，给枚举类型中的每一个元素指定一个整型常量值(也称为序号值)。若枚举类型定义中没有指定元素的整型常量值，则整型常量值从0开始依次递增，因此，weekdays枚举类型的七个元素Sun、Mon、Tue、Wed、Thu、Fri、Sat对应的整型常量值分别为0、1、2、3、4、5、6。 注意：在定义枚举类型时，也可指定元素对应的整型常量值。 123enum boolean &#123; TRUE=1 ,FALSE=0 &#125;;该定义规定：TRUE的值为1，而FALSE的值为0 12enum colors &#123;red=5,blue=1,green,black,white,yellow&#125;; 1该定义规定red为5 ，blue为1，其后元素值从2 开始递增加1。green、black、white、yellow的值依次为2、3、4、5。 此时，整数5将用于表示二种颜色red与yellow。通常两个不同元素取相同的整数值是没有意义的。枚举类型的定义只是定义了一个新的数据类型，只有用枚举类型定义枚举变量才能使用这种数据类型。 enum 与 class、interface 具有相同地位；可以继承多个接口；可以拥有构造器、成员方法、成员变量；1.2 枚举类与普通类不同之处 默认继承 java.lang.Enum 类，所以不能继承其他父类；其中 java.lang.Enum 类实现了 java.lang.Serializable 和 java.lang.Comparable 接口； 使用 enum 定义，默认使用 final 修饰，因此不能派生子类； 构造器默认使用 private 修饰，且只能使用 private 修饰； 枚举类所有实例必须在第一行给出，默认添加 public static final 修饰，否则无法产生实例； 2. 使用2.1 常量12345public enum Color &#123; RED, GREEN, BLANK, YELLOW &#125; 2.2 switch12345678910111213141516171819enum Signal &#123; GREEN, YELLOW, RED &#125; public class TrafficLight &#123; Signal color = Signal.RED; public void change() &#123; switch (color) &#123; case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; &#125; &#125; &#125; 2.3 向枚举类中添加新方法如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。 12345678910111213141516171819202122232425262728293031323334public enum Color &#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4) ; // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; // 普通方法 public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; // get set 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; &#125; 2.4 覆盖枚举的方法12345678910111213141516public enum Color &#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //覆盖方法 @Override public String toString() &#123; return this.index+\"_\"+this.name; &#125; &#125; 2.5 实现接口所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。 12345678910111213141516171819202122232425public interface Behaviour &#123; void print(); String getInfo(); &#125; public enum Color implements Behaviour&#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //接口方法 @Override public String getInfo() &#123; return this.name; &#125; //接口方法 @Override public void print() &#123; System.out.println(this.index+\":\"+this.name); &#125; &#125; 2.6 使用接口组织枚举123456789101112131415161718public class 用接口组织枚举 &#123; public static void main(String[] args) &#123; Food cf = chineseFood.dumpling; Food jf = Food.JapaneseFood.fishpiece; for (Food food : chineseFood.values()) &#123; System.out.println(food); &#125; for (Food food : Food.JapaneseFood.values()) &#123; System.out.println(food); &#125; &#125; &#125; interface Food &#123; enum JapaneseFood implements Food &#123;suse, fishpiece&#125; &#125; enum chineseFood implements Food &#123;dumpling, tofu&#125; 2.7 关于枚举集合的使用java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的 key是enum类型，而value则可以是任意类型。 一个EnumMap的例子 123456789public class 枚举类集合 &#123; public static void main(String[] args) &#123; EnumMap&lt;Color, String&gt; map = new EnumMap&lt;Color, String&gt;(Color.class); map.put(Color.Blue, \"Blue\"); map.put(Color.Yellow, \"Yellow\"); map.put(Color.Red, \"Red\"); System.out.println(map.get(Color.Red)); &#125;&#125; 3. 注意建议： 枚举类名带上Enum后缀，枚举成员名称大写，单词间用下划线隔开 枚举类型对象之间值的比较，可以用==，equals 123public final boolean equals(Object other) &#123; return this==other;&#125; 4. 原理枚举类实现计算器 1234567891011121314151617181920212223242526272829303132333435363738394041424344public enum Operator &#123; ADD (\"+\") &#123; @Override public int calculate(int a, int b) &#123; return a + b; &#125; &#125;, SUBTRACT (\"-\") &#123; @Override public int calculate(int a, int b) &#123; return a - b; &#125; &#125;, MULTIPLY (\"*\") &#123; @Override public int calculate(int a, int b) &#123; return a * b; &#125; &#125;, DIVIDE (\"/\") &#123; @Override public int calculate(int a, int b) &#123; if (b == 0) &#123; throw new IllegalArgumentException(\"divisor must not be 0\"); &#125; return a / b; &#125; &#125;; Operator (String operator) &#123; this.operator = operator; &#125; private String operator; public abstract int calculate(int a, int b); public String getOperator() &#123; return operator; &#125; &#125; 枚举本质上是通过普通的类来实现的，只是编译器为我们进行了处理。每个枚举类型都继承自java.lang.Enum，并自动添加了values和valueOf方法。 而每个枚举常量是一个静态常量字段，使用内部类实现，该内部类继承了枚举类。所有枚举常量都通过静态代码块来进行初始化，即在类加载期间就初始化。 另外通过把clone、readObject、writeObject这三个方法定义为final的，同时实现是抛出相应的异常。这样保证了每个枚举类型及枚举常量都是不可变的。可以利用枚举的这两个特性来实现线程安全的单例。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础13：Java反射","date":"2018-11-07T16:50:57.000Z","path":"2018/11/08/Java基础13：Java反射/","text":"1. 什么是反射 反射是Java程序开发语言的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 反射框架主要提供以下功能 1.在运行时判断任意一个对象所属的类； 2.在运行时构造任意一个类的对象； 3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 4.在运行时调用任意一个对象的方法 重点：是运行时而不是编译时 2. 用途如果需要运行时动态加载需要加载的对象，就需要用到反射，比如Spring 利用xml加载bean。 2. 反射的基础：关于Class类的操作1、Class是一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性 2、对象照镜子后（反射）可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。 3、对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个Class对象包含了特定某个类的有关信息。 4、Class 对象只能由系统建立对象 5、一个类在 JVM 中只会有一个Class实例 1234567891011121314151617181920212223//总结一下就是，JDK有一个类叫做Class，这个类用来封装所有Java类型，包括这些类的所有信息，JVM中类信息是放在方法区的。//所有类在加载后，JVM会为其在堆中创建一个Class&lt;类名称&gt;的对象，并且每个类只会有一个Class对象，这个类的所有对象都要通过Class&lt;类名称&gt;来进行实例化。//上面说的是JVM进行实例化的原理，当然实际上在Java写代码时只需要用 类名称就可以进行实例化了。public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; private static final int ANNOTATION= 0x00002000; private static final int ENUM = 0x00004000; private static final int SYNTHETIC = 0x00001000; private static native void registerNatives(); static &#123; registerNatives(); &#125; //私有构造方法，只能jvm实例化 private Class(ClassLoader loader) &#123; classLoader = loader; &#125; 2.2 获取Class对象Class.forName(“xxx”);// 类的全限定名 对象.class; 对象.getClass(); 2.3 判断是否为某个类的实例一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法： public native boolean isInstance(Object obj); 2.4 通过反射创建实例 使用Class对象的newInstance()方法创建Class对象对应类的实例。 调用的类必须有无参的构造器。 使用Class对象获取到Constructor对象，通过Constructor对象的newInstance() 12345678910111213141516171819202122232425262728/** * Created by Joe */public class Demo &#123; public Demo() &#123; &#125; public void print(int i) &#123; System.out.println(\"测试方法\" + i); &#125; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; //1.new 对象 Demo demo1 = new Demo(); demo1.print(1); //2.反射 Class对象的new Instance()方法 Class&lt;Demo&gt; clazz = Demo.class; Demo demo2 = clazz.newInstance(); demo2.print(2); //3.反射 Class对象获取Constructor对象，再使用Constructor对象的newInstance方法。 Class&lt;Demo&gt; c = Demo.class; Constructor&lt;Demo&gt; constructor = c.getConstructor(); Demo demo3 = constructor.newInstance(); demo3.print(3); &#125;&#125; 输出 123测试方法1测试方法2测试方法3 2.5 获取方法 getDeclaredMethods()方法 返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 getMethods()方法 返回某个类的所有public方法，包括其继承类的公用方法。 getMethod()方法 返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象 定义一个测试类 12345678910111213141516171819202122232425262728/** * Created by Joe */public class TestReflection &#123; private int a = 1; int b = 2; public TestReflection()&#123; &#125; public TestReflection(int a, int b) &#123; this.a = a; this.b = b; &#125; private void test1(String str) &#123; System.out.println(\"test1 \" + str); &#125; public void test2() &#123; System.out.println(\"test2\"); &#125; &#125; 获取到Class对象 1Class&lt;TestReflection&gt; clazz = TestReflection.class; 12345//获取所有public方法包括继承来的Method[] methods1 = clazz.getMethods();for (Method method : methods1) &#123; System.out.println(method.getName());&#125; 输出 1234567891011maintest2waitwaitwaitequalstoStringhashCodegetClassnotifynotifyAll 可以看到，输出中包括了Object类中的一些public方法 12345//获取此类所有方法不包括继承的Method[] methods2 = clazz.getDeclaredMethods();for (Method method : methods2) &#123; System.out.println(method.getName());&#125; 输出 123maintest1test2 1234567//获取特定方法:test1Method method1 = clazz.getMethod(&quot;test1&quot;, String.class);method1.invoke(clazz.newInstance(), &quot;hello world&quot;);//获取特定方法:test2Method method2 = clazz.getMethod(&quot;test2&quot;);method2.invoke(clazz.newInstance()); 输出 12test1 hello worldtest2 2.6 获取字段 getFields(): 访问公有的成员变量getDeclaredFields()：所有已声明的成员变量。但不能得到其父类的成员变量getFileds和getDeclaredFields用法同上（参照Method） getField(String name) 访问特定字段 2.7 调用方法invoke(调用此方法的实例对象，参数类型（如果有）) 2.8 通过反射越过泛型检查因为泛型擦除在编译过后，反射在运行时，所以可以越过泛型检查 12345678910111213List&lt;String&gt; lists = new ArrayList&lt;&gt;();//编译期泛型检查lists.add(\"aaa\");lists.add(\"bbb\");Class clazz = lists.getClass();Method m = clazz.getMethod(\"add\", Object.class);//运行时泛型擦除m.invoke(lists, 233);for (Object list : lists) &#123; System.out.println(list);&#125; 输出 123aaabbb233","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础12：Java Class类和Object类","date":"2018-11-07T16:50:27.000Z","path":"2018/11/08/Java基础12：Java-Class类和Object类/","text":"1. Class类 参考程序员江湖 Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。 这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。 Class类也是类的一种，只是名字和class关键字高度相似。Java是大小写敏感的语言。 Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象 Class类的对象不能像普通类一样，以 new shapes() 的方式创建，它的对象只能由JVM创建，因为这个类没有public构造函数 1234567891011121314151617public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; private static final int ANNOTATION= 0x00002000; private static final int ENUM = 0x00004000; private static final int SYNTHETIC = 0x00001000; private static native void registerNatives(); static &#123; registerNatives(); &#125; //私有构造方法，只能jvm实例化 private Class(ClassLoader loader) &#123; classLoader = loader; &#125; Class类的作用是运行时提供或获得某个对象的类型信息 我们都知道所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象。 我们自己无法生成一个Class对象（构造函数为private)，而 这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。 1234//通过该方法可以动态地将字节码转为一个Class类对象protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError &#123; return defineClass(name, b, off, len, null);&#125; 我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图所示： 2. 获取Class对象请注意，以下这些方法都是值、指某个类对应的Class对象已经在堆中生成以后，我们通过不同方式获取对这个Class对象的引用。而上面说的DefineClass才是真正将字节码加载到虚拟机的方法，会在堆中生成新的一个Class对象。 Class.forName()方法 public class shapes{} Class obj= Class.forName(“shapes”);//类的全限定名 第二种办法，使用对象的getClass()函数 public class shapes{} shapes s1=new shapes(); Class obj=s1.getClass(); Class obj1=s1.getSuperclass();//这个函数作用是获取shapes类的父类的类型 第三种办法，使用类字面常量 Class obj=String.class;Class obj1=int.class;注意，使用这种办法生成Class类对象时，不会使JVM自动加载该类（如String类）。==而其他办法会使得JVM初始化该类。== 3. 生成目标类的实例获取一个Class类的对象后，可以用 newInstance() 函数来生成目标类的一个实例。然而，该函数并不能直接生成目标类的实例，只能生成object类的实例 Class obj=Class.forName(“shapes”);Object ShapesInstance=obj.newInstance();使用泛化Class引用生成带类型的目标实例 Class obj=shapes.class;shapes newShape=obj.newInstance(); 因为有了类型限制，所以使用泛化Class语法的对象引用不能指向别的类。 12345678910111213141516171819202122 Class obj1 = int.class; Class&lt;Integer&gt; obj2 = int.class; obj1=double.class; //obj2=double.class; 这一行代码是非法的，obj2不能改指向别的类 然而，有个灵活的用法，使得你可以用Class的对象指向基类的任何子类。 Class&lt;? extends Number&gt; obj = int.class; obj=Number .class; obj=double.class; //因此，以下语法生成的Class对象可以指向任何类。 Class&lt;?&gt; obj = int.class; obj=double.class; obj=shapes .class; //最后一个奇怪的用法是，当你使用这种泛型语法来构建你手头有的一个Class类的对象的基类对象时，必须采用以下的特殊语法 public class shapes &#123; &#125; class round extends shapes &#123; &#125; Class&lt;round&gt; rclass = round.class; Class&lt;? super round&gt; sclass = rclass.getSuperClass();//Class&lt;shapes&gt; sclass=rclass.getSuperClass(); 我们明知道，round的基类就是shapes，但是却不能直接声明 Class &lt; shapes &gt;，必须使用特殊语法 Class &lt; ? super round &gt; API getClassLoader**()** 获取该类的类装载器。 getComponentType() 如果当前类表示一个数组，则返回表示该数组组件的Class对象，否则返回null。 getConstructor(Class[]) 返回当前Class对象表示的类的指定的公有构造子对象。 getConstructors() 返回当前Class对象表示的类的所有公有构造子对象数组。 getDeclaredConstructor(Class[]) 返回当前Class对象表示的类的指定已说明的一个构造子对象。 getDeclaredConstructors() 返回当前Class对象表示的类的所有已说明的构造子对象数组。 getDeclaredField(String) 返回当前Class对象表示的类或接口的指定已说明的一个域对象。 getDeclaredFields() 返回当前Class对象表示的类或接口的所有已说明的域对象数组。 getDeclaredMethod(String,Class[]) 返回当前Class对象表示的类或接口的指定已说明的一个方法对象。 getDeclaredMethods() 返回Class对象表示的类或接口的所有已说明的方法数组。 getField(String) 返回当前Class对象表示的类或接口的指定的公有成员域对象。 getFields() 返回当前Class对象表示的类或接口的所有可访问的公有域对象数组。 getInterfaces() 返回当前对象表示的类或接口实现的接口。 getMethod(String,Class[]) 返回当前Class对象表示的类或接口的指定的公有成员方法对象。 getMethods() 返回当前Class对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。 getModifiers() 返回该类或接口的Java语言修改器代码。 getName() 返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。 getResource(String) 按指定名查找资源。 getResourceAsStream(String) 用给定名查找资源。 getSigners() 获取类标记。 getSuperclass() 如果此对象表示除Object外的任一类,那么返回此对象的父类对象。 isArray() 如果Class对象表示一个数组则返回true,否则返回false。 isAssignableFrom(Class) 判定Class对象表示的类或接口是否同参数指定的Class表示的类或接口相同，或是其父类。 isInstance(Object) 此方法是Java语言instanceof操作的动态等价方法。 isInterface() 判定指定的Class对象是否表示一个接口类型。 isPrimitive() 判定指定的Class对象是否表示一个Java的基类型。 newInstance() 创建类的新实例。 toString() 将对象转换为字符串。 4. Object类 参考 a Javaer Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。 Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法，其中9个被所有子类继承 4. 1 public Object(); 大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。 为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。 当然，并不是所有的类都是通过此种方式去构建，也自然的，并不是所有的类构造函数都是public。 4.2 private static native void registerNatives();registerNatives函数前面有native关键字修饰，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。 方法的具体实现体在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。 既然如此，可能有人会问，registerNatives()修饰符为private，且并没有执行，作用何以达到？其实，在Java源码中，此方法的声明后有紧接着一段静态代码块： 1234567private static native void registerNatives(); static &#123; registerNatives(); &#125; 4.3 protected native Object clone() throws CloneNotSupportedException; 看，clode()方法又是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone英文翻译为”克隆”。Java术语表述为：clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。 明白了clone的含义后，接下来看看如果调用clone()函数对象进行此克隆操作。 首先看一下下面的这个例子： 1234567891011121314package com.corn.objectsummary; import com.corn.Person; public class ObjectTest &#123; public static void main(String[] args) &#123; Object o1 = new Object(); //下面代码出错 The method clone() from the type Object is not visible Object clone = o1.clone(); &#125; &#125; 回到Object类中clone()方法的定义，可以看到其被声明为protected，估计问题就在这上面了，protected修饰的属性或方法表示：在同一个包内或者不同包的子类可以访问。显然，Object类与ObjectTest类在不同的包中，但是ObjectTest继承自Object，是Object类的子类，于是，现在却出现子类中通过Object引用不能访问protected方法，原因在于对”不同包中的子类可以访问”没有正确理解。 “不同包中的子类可以访问”，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外） 下面代码因为此时的主调已经是子类的引用了，所以正常编译，但运行时会报错 1234567891011121314151617package com.corn.objectsummary; public class ObjectTest &#123; public static void main(String[] args) &#123; ObjectTest ot1 = new ObjectTest(); try &#123; ObjectTest ot2 = (ObjectTest) ot1.clone(); &#125; catch (CloneNotSupportedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 上述代码在运行过程中会抛出”java.lang.CloneNotSupportedException”,表明clone()方法并未正确执行完毕，问题的原因在与Java中的语法规定： clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。 clone方法实现的是浅拷贝，只拷贝当前对象，并且在堆中分配新的空间，放这个复制的对象。但是对象如果里面有其他类的子对象，那么就不会拷贝到新的对象中。 深拷贝和浅拷贝的区别 浅拷贝浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的。 4.4 public final native Class&lt;?&gt; getClass();getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。 首先解释下”类对象”的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。 4.5 public boolean equals(Object obj);==与equals在Java中经常被使用，大家也都知道==与equals的区别： ==表示的是变量值完全相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）； equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。 实际上，上面说法是不严谨的，更多的只是常见于String类中。首先看一下Object类中关于equals()方法的定义： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 由此可见，Object原生的equals()方法内部调用的正是==，与==具有相同的含义。既然如此，为什么还要定义此equals()方法？ equlas()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？ 如上，在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到object基类。 Java中的约定：重写equals()方法必须重写hasCode()方法。 4.6 public native int hashCode();hashCode()方法返回一个整形数值，表示该对象的哈希码值。 hashCode()具有如下约定： 1).在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致; 2).如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等； 3).反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。 即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt; equals()相等 =&gt; hashCode()相等。因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等 =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。 4.7 public String toString();toString()方法返回该对象的字符串表示。先看一下Object中的具体方法体： 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); &#125; toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。 getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。 toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。 4.8 - 4.12 wait(…)/notify(…)/notifyAll()wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。 wait(long timeout)/wait(long timeout, int nanos)：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notisfy()/notisfyAll()方法，或超过指定的超时时间量。 notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。 wait(…)/notify()|notifyAll()方法只能在同步代码块中才能使用。 为什么却是Object这个基类所具有的方法？原因在于理论上任何对象都可以视为线程同步中的监听器，且wait(…)/notify()|notifyAll()方法只能在同步代码块中才能使用。 wait源码 123public final void wait() throws InterruptedException &#123; wait(0); &#125; 且wait(long timeout, int nanos)方法定义内部实质上也是通过调用wait(long timeout)完成。而wait(long timeout)是一个native方法。因此，wait(…)方法本质上都是native方式实现。 notify()/notifyAll()方法也都是native方法。 4.13 protected void finalize();finalize方法主要与Java垃圾回收机制有关。首先我们看一下finalized方法在Object中的具体定义： 1protected void finalize() throws Throwable &#123; &#125; 我们发现Object类中finalize方法被定义成一个空方法，为什么要如此定义呢？finalize方法的调用时机是怎么样的呢？ 首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础11：Java泛型详解","date":"2018-11-07T16:49:40.000Z","path":"2018/11/08/Java基础11：Java泛型详解/","text":"1. 泛型概述1.1 定义 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？ 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用/调用时传入具体的类型（类型实参）。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 1.2 为什么要引入泛型举个例子： 12345678List arrayList = new ArrayList();arrayList.add(\"aaaa\");arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d(\"泛型测试\",\"item = \" + item);&#125; 输出 1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 为了解决这种参数类型不一致的情况，Java引入了泛型。 2. 原理泛型只在编译阶段有效 123List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 在编译之后程序会进行去泛型化操作。在正确检验参数类型后，会进行泛型擦除操作，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d(\"泛型测试\",\"类型相同\");&#125; 输出 1泛型测试:类型相同 3. 用法泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 3.1 泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组 类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 定义一个泛型类 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 使用泛型类 12345678//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型//传入的实参类型需与泛型的类型参数类型相同，即为Integer.Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);//传入的实参类型需与泛型的类型参数类型相同，即为String.Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(\"key_vlaue\");Log.d(\"泛型测试\",\"key is \" + genericInteger.getKey());Log.d(\"泛型测试\",\"key is \" + genericString.getKey()); 对于泛型类，也可以不传泛型参数，这样的话泛型类就和普通类一样可以接受不同类型的参数。 3.2 泛型接口泛型接口与泛型类的定义及使用基本相同。 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，未传入泛型实参时： 1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 当实现泛型接口的类，传入泛型实参时： 1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;\"Apple\", \"Banana\", \"Pear\"&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 3.3 泛型通配符 我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic&lt;Ingeter&gt;与Generic&lt;Number&gt;实际上是相同的一种基本类型。那么问题来了，在使用Generic&lt;Number&gt;作为形参的方法中，能否使用Generic&lt;Ingeter&gt;的实例传入呢？在逻辑上类似于Generic&lt;Number&gt;和Generic&lt;Ingeter&gt;是否可以看成具有父子关系的泛型类型呢？ 使用Generic&lt;T&gt;这个泛型类继续 123public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(\"泛型测试\",\"key value is \" + obj.getKey());&#125; 12345678Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);showKeyValue(gNumber);//编译通过showKeyValue(gInteger);//编译错误// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt;// showKeyValue(gInteger); 我们可以看到Generic&lt;Integer&gt;不能被看作为Generic`的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 为了解决上面出现的问题，需要使用类型通配符。 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 改进 123public void showKeyValue1(Generic&lt;?&gt; obj)&#123; Log.d(\"泛型测试\",\"key value is \" + obj.getKey());&#125; 3.4 泛型方法不是带有泛型参数的方法就叫泛型方法。 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。 通过在访问修饰符和返回值之间定义泛型来声明泛型方法。 123public &lt;T&gt; T test(T t)&#123; return t;&#125; 第一个用来声明泛型方法，第二个T为返回类型。 实例 12345678910111213141516171819//泛型类public class Test&lt;T&gt;&#123; private T key; //构造方法 public Test(T key)&#123; this.key = key; &#125; //泛型类中普通方法，不是泛型方法 public T getKey()&#123; return key; &#125; //泛型方法 定义泛型方法参数V可以与类的T一样 public &lt;V&gt; void demo(V value)&#123; System.out.println(value); &#125;&#125; 4. 可变参数123456//可以匹配所有类型的参数public &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; Log.d(\"泛型测试\",\"t is \" + t); &#125;&#125; 5. 静态方法与泛型静态方法无法访问到类上定义的泛型；如果静态方法需要使用泛型，需要将静态方法定义成泛型方法。 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： \"StaticGenerator cannot be refrenced from static context\" */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 6. 泛型上下边界使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class 泛型通配符与边界 &#123; public void showKeyValue(Generic&lt;Number&gt; obj) &#123; System.out.println(\"key value is \" + obj.getKey()); &#125; @Test public void main() &#123; Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123); Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456); showKeyValue(gNumber); //泛型中的子类也无法作为父类引用传入 showKeyValue(gInteger); &#125; //直接使用？通配符可以接受任何类型作为泛型传入 public void showKeyValueYeah(Generic&lt;?&gt; obj) &#123; System.out.println(obj); &#125; //只能传入number的子类或者number public void showKeyValue1(Generic&lt;? extends Number&gt; obj) &#123; System.out.println(obj); &#125; //只能传入Integer的父类或者Integer public void showKeyValue2(Generic&lt;? super Integer&gt; obj) &#123; System.out.println(obj); &#125; @Test public void testup() &#123; //这一行代码编译器会提示错误，因为String类型并不是Number类型的子类 showKeyValue1(generic1); Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(\"11111\"); Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222); Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f); Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56); showKeyValue1(generic2); showKeyValue1(generic3); showKeyValue1(generic4); &#125; @Test public void testdown() &#123; Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(\"11111\"); Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222); Generic&lt;Number&gt; generic3 = new Generic&lt;Number&gt;(2); // showKeyValue2(generic1);本行报错，因为String并不是Integer的父类 showKeyValue2(generic2); showKeyValue2(generic3); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础10：理解Java异常","date":"2018-11-07T16:49:17.000Z","path":"2018/11/08/Java基础10：理解Java异常/","text":"1. 为什么要使用异常为了提高程序的健壮性，提高系统可用率。 首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。 如果没有异常机制，程序只能通过运行结果推断是否发生异常或者错误。但这样会降低程序的可读性，并且通过结果推断不一定正确，且很难定位异常发生的位置，降低了代码的可用性。 Java中的异常处理机制保证了代码的健壮性。使用异常可以很方便地捕获到程序运行过程中发生的错误，并且可以集中处理异常，使代码可读性较强。 2. 异常体系 可以看出，Throwable是Java中所有错误和异常的超类（万物皆可抛）。它有两个子类，Error，Exception 非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。 对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。 检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。java强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。 3. 异常处理在异常可能发生的地方，用try-catch-finally(可选)捕获或者throws抛出交给函数调用者处理。 123456789101112@Testpublic void testException() throws IOException &#123; //FileInputStream的构造函数会抛出FileNotFoundException FileInputStream fileIn = new FileInputStream(\"E:\\\\a.txt\"); int word; // read方法会抛出IOException while ((word = fileIn.read()) != -1) &#123; System.out.print((char) word); &#125; // close方法会抛出IOException fileIn.close();&#125; 123456789101112131415161718192021222324252627public class 异常处理方式 &#123; @Test public void main() &#123; try &#123; //try块中放可能发生异常的代码。 InputStream inputStream = new FileInputStream(\"a.txt\"); //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。 int i = 1 / 0; //如果发生异常，则尝试去匹配catch块。 throw new SQLException(); // 使用1.8jdk同时捕获多个异常，runtimeException也可以捕获。只是捕获后虚拟机也无法处理，所以不建议捕获。 &#125; catch (SQLException | IOException | ArrayIndexOutOfBoundsException exception) &#123; System.out.println(exception.getMessage()); //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。 // catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 // 在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 // 如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。 // 如果try中没有发生异常，则所有的catch块将被忽略。 //多个catch存在子类Exception在父类Exception之前 &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; //finally块通常是可选的。 // 无论异常是否发生，异常是否匹配被处理，finally都会执行。 // finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 &#125; &#125; 一个try至少由一个catch块或者finally或者都有。 4. throwsthrows是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。 采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。 5. finallyfinally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。 良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。 需要注意的地方: 1、finally块没有处理异常的能力。处理异常的只能是catch块。 2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。 3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。 6. throw自行抛出异常 123456//保证输入i为正数public void test(int i)&#123; if(i &lt;= 0)&#123; return new ArgumentIllegalException(); &#125;&#125; 7. 自定义异常如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。 其中包括 一个无参构造函数一个带有String参数的构造函数，并传递给父类的构造函数。一个带有String参数和Throwable参数，并都传递给父类构造函数一个带有Throwable 参数的构造函数，并传递给父类的构造函1数。 12345678910111213141516171819public class IOException extends Exception &#123; static final long serialVersionUID = 1L; public IOException() &#123; super(); &#125; public IOException(String message) &#123; super(message); &#125; public IOException(String message, Throwable cause) &#123; super(message, cause); &#125; public IOException(Throwable cause) &#123; super(cause); &#125; &#125; 8. 遇到return在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。 12345678910111213@Testpublic void test() &#123; int re = bar(); System.out.println(re); &#125; private static int bar() &#123; try &#123; return 5; &#125; finally &#123; System.out.println(\"finally\"); &#125; &#125; 输出 12finally5 finally 中return会覆盖try或catch中return 123456789101112131415public static void main(String[] args) &#123; int re = bar(); System.out.println(re); &#125; private static int bar() &#123; try &#123; int i = 1 / 0;//不管有没有异常输出都为3 return 1; &#125; catch (Exception e) &#123; return 2; &#125; finally &#123; return 3; &#125; &#125; 综上，为了代码可读性和可维护性，尽量不要在try-catch-finally语句中使用finally","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础9：深入理解内部类","date":"2018-11-07T16:48:43.000Z","path":"2018/11/08/Java基础9：深入理解内部类/","text":"1. 定义 内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类 1.1 共性(1)内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。 (2)内部类不能用普通的方式访问。 (3)内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量 。 (4)外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问 内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。 因为当某个外围类的对象创建内部类的对象时，此内部类会捕获一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。 1.2 好处静态内部类的作用： 1 只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类。 2 由于Java规定静态内部类不能用使用外在类的非静态属性和方法，所以只是为了方便管理类结构而定义。于是我们在创建静态内部类的时候，不需要外部类对象的引用。 非静态内部类的作用： 1 内部类继承自某个类或实现某个接口，内部类的代码操作创建其他外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。 2 使用内部类最吸引人的原因是:每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响 3 如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。 从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了”多重继承”。 2. 区别2. 1 那静态内部类与普通内部类有什么区别呢？ （1）静态内部类不持有外部类的引用在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性（如果是private权限也能访问，这是由其代码位置所决定的），其他则不能访问。 （2）静态内部类不依赖外部类普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，也就是说它们会同生同死，一起声明，一起被垃圾回收器回收。而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类还是可以存在的。 （3）普通内部类不能声明static的方法和变量 普通内部类不能声明static的方法和变量，注意这里说的是变量，常量（也就是final static修饰的属性）还是可以的，而静态内部类形似外部类，没有任何限制。 3. 内部类的加载 内部类是延时加载的，也就是说只会在第一次使用时加载。不使用就不加载，所以可以很好的实现单例模式。 不论是静态内部类还是非静态内部类都是在第一次使用时才会被加载。 对于非静态内部类是不能出现静态模块（包含静态块，静态属性，静态方法等） 非静态类的使用需要依赖于外部类的对象 4. 成员内部类类比成员变量，可以被访问修饰符修饰。可以访问外部类的所有变量，包括private。需要依托外部类才能创建。 5. 方法内部类在方法中定义的内部类称为局部内部类。与局部变量类似，局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，和此外围类所有的成员。 局部内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。 6. 匿名内部类简单地说：匿名内部类就是没有名字的内部类，并且，匿名内部类是局部内部类的一种特殊形式。 匿名内部类不能有构造方法。 匿名内部类不能定义任何静态成员、方法和类。 匿名内部类不能是public,protected,private,static。只能创建匿名内部类的一个实例。 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。 因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。 内部类引用外部方法的参数时，参数必须为final","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础8：Java类及包访问权限","date":"2018-11-07T16:48:04.000Z","path":"2018/11/08/Java基础8：Java类及包访问权限/","text":"1. 问题：一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。一个文件中可以只有非public类，如果只有一个非public类，此类可以跟文件名不同。 2. 为什么一个java源文件中只能有一个public类？1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。 2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。 3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。 3 . 在java文件中是否可以没有public类public类不是必须的，java文件中可以没有public类。 4. 为什么这个public的类的类名必须和文件名相同是为了方便虚拟机在相应的路径中找到相应的类所对应的字节码文件。 5. main函数作为函数的入口 public：代表着该函数访问权限是最大的 static：代表主函数随着类的加载就已经存在了 void：主函数没有具体的返回值 main：不是关键字，但是一个特殊的单词，能够被JVM识别（String[] args）：函数的参数，参数类型是一个数组，该数组中的元素师字符串，字符串数组。main(String[] args) 字符串数组的 此时空数组的长度是0，但也可以在 运行的时候向其中传入参数。 6. 外部类的访问权限外部类只能用public和default修饰。 为什么要对外部类或类做修饰呢？ 1.存在包概念：public 和 default 能区分这个外部类能对不同包作一个划分 （default修饰的类，其他包中引入不了这个类，public修饰的类才能被import） protected是包内可见并且子类可见，但是当一个外部类想要继承一个protected修饰的非同包类时，压根找不到这个类，更别提几层了 private修饰的外部类，其他任何外部类都无法导入它。 ​ Modifier Class Package Subclass World public Y Y Y Y protected Y Y Y N no modifier Y Y N N private Y N N N 7. Java包的命名规则 以 java.* 开头的是Java的核心包，所有程序都会使用这些包中的类； 以 javax. 开头的是扩展包，x 是 extension 的意思，也就是扩展。虽然 javax. 是对 java. 的优化和扩展，但是由于 javax. 使用的越来越多，很多程序都依赖于 javax.，所以 javax. 也是核心的一部分了，也随JDK一起发布。 以 org.* 开头的是各个机构或组织发布的包，因为这些组织很有影响力，它们的代码质量很高，所以也将它们开发的部分常用的类随JDK一起发布。 在包的命名方面，为了防止重名，有一个惯例：大家都以自己域名的倒写形式作为开头来为自己开发的包命名，例如百度发布的包会以 com.baidu. 开头，w3c组织发布的包会以 org.w3c. 开头，微学苑发布的包会以 net.weixueyuan.* 开头…… 组织机构的域名后缀一般为 org，公司的域名后缀一般为 com，可以认为 org. 开头的包为非盈利组织机构发布的包，它们一般是开源的，可以免费使用在自己的产品中，不用考虑侵权问题，而以 com. 开头的包往往由盈利性的公司发布，可能会有版权问题，使用时要注意。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础7：代码块与加载顺序","date":"2018-11-07T16:46:56.000Z","path":"2018/11/08/Java基础7：代码块与加载顺序/","text":"代码块：用{}包围的代码 Java中，有 局部代码块 静态代码块 静态代码块 1. 局部代码块位置：局部位置（方法内部） 作用：限定变量的生命周期，尽早释放，节约内存 调用：调用其所在的方法时执行 2. 构造代码块位置：类成员的位置，就是类中方法之外的位置 作用：把多个构造方法共同的部分提取出来，共用构造代码块 调用：每次调用构造方法时，都会优先于构造方法执行，也就是每次new一个对象时自动调用，对 对象的初始化 3. 静态代码块位置：类成员位置，用static修饰的代码块 作用：对类进行一些初始化 只加载一次，当new多个对象时，只有第一次会调用静态代码块，因为，静态代码块 是属于类的，所有对象共享一份 调用: new 一个对象时自动调用 1234567891011121314151617181920212223242526272829303132333435363738/** * Created by Joe */public class Food &#123; static &#123; System.out.println(\"父类静态代码块\"); &#125; &#123; System.out.println(\"父类普通代码块\"); &#125; public Food() &#123; System.out.println(\"父类构造函数\"); &#125;&#125;class Apple extends Food &#123; static &#123; System.out.println(\"子类静态代码块\"); &#125; &#123; System.out.println(\"子类普通代码块\"); &#125; public Apple() &#123; System.out.println(\"子类构造函数\"); &#125; public static void main(String[] args) &#123; Apple a = new Apple(); &#125;&#125; 输出： 123456父类静态代码块子类静态代码块父类普通代码块父类构造函数子类普通代码块子类构造函数","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础6：抽象类及接口","date":"2018-11-07T16:45:52.000Z","path":"2018/11/08/Java基础6：抽象类及接口/","text":"1. 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class A &#123;&#125;interface M extends N,L&#123;&#125;interface N&#123;&#125;interface L&#123;&#125;interface 接口 &#123; public final int i = 1;//变量默认都为public final修饰 final A a = null;//基本数据类型和引用都一样 //protected void a();//报错 //private //报错 public abstract void a();// 方法都是public abstract修饰的。 //void b()&#123;&#125; 报错，接口里的方法不能有方法体，也不能有&#123;&#125;，只能有()； // final void b(); // 注意，抽象方法不能加final。因为final方法不能被重写。 //但如果抽象方法不被重写那就没有意义了，因为他根本没有代码体。&#125;abstract class 抽象类 &#123; public final int i = 1;//变量并没有被pulic和final修饰，只是一般的成员变量 public final A a = null; private void A()&#123;&#125;//抽象类可以有具体方法 abstract void AA();//抽象方法没有方法体 //private abstract void B();//报错，组合非法 // 因为private修饰的方法无法被子类重写，所以和final一样，使抽象方法无法被实现。&#125;//抽象类也可以被实例化，举例说明abstract class B&#123; B() &#123; System.out.println(\"b init\"); &#125;&#125;class C extends B&#123; C()&#123; super(); System.out.println(\"c init\"); &#125;&#125;public class 接口对比抽象类 &#123; @Test public void test() &#123; C c = new C(); //结果先实例化B，再实例化C。 //因为会调用到父类的构造方法。 &#125;&#125; 2.接口高度抽象 接口可以多继承 接口中变量默认为public static final修饰，且必须被赋值（不能只定义） 接口中方法默认为public abstract(JDK1.8中可以有default方法) 不能有构造器 3. 抽象类包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。 抽象类可以有非抽象方法。(不需要必须有抽象方法) abstract可以修饰类，方法，不能修饰字段。 抽象方法的body不能有{}，而是; 可以有构造器 可以有静态方法 不可以用来创建对象，但可以被实例化（继承关系） 抽象方法可以有public、protected和default这些修饰符 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。 4. 区别接口可以多继承，抽象类不能 接口没有构造方法，抽象类可以有 接口不能有普通成员变量，抽象类可以有 接口类不可以有普通方法（Java8中可以有默认实现），抽象类可以有 抽象类中抽象方法类型可以是public,protected,接口中只能为public 接口中不能有静态方法，抽象类中可以有 抽象类和接口都可以有静态成员变量，但接口只能是public static final，抽象类任意。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础5：final关键字","date":"2018-11-07T16:45:26.000Z","path":"2018/11/08/Java基础5：final关键字/","text":"1. 用法 final修饰类，表示这个类不能被继承 final修饰方法，表示这个方法不能被重写。 final修饰变量，如果这个变量指向一个基本类型，则这个变量为一个常量，如果这个变量指向一个对象的引用，则这个变量指向的引用不可变。 2. 修饰类 一个典型的例子是Java,lang.String类。 在这个类中，String被final所修饰，表示这个类不能被继承。此外，在String内部定义了一个char数组，也被final所修饰，且类中没有修改value数组内容的代码。综上，我们可以说String数组虽然没有被synchronized所修饰，但它是线程安全的。 3. 修饰方法 当final修饰方法时，表示这个方法不能被重写。重写基于动态绑定，而final方法在编译阶段绑定，称为静态绑定(static binding)。 4. 修饰变量 当final修饰成员变量时，必须在声明时初始化或在构造函数中初始化。 当final修饰局部变量时，必须在声明时赋值。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础4：装箱，拆箱，类型转换","date":"2018-11-07T16:41:47.000Z","path":"2018/11/08/Java基础4：装箱，拆箱，类型转换/","text":"1. 装箱和拆箱自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转换。 基本类型： byte short int long char float double boolean 包装类型 Byte Short Integer Long Character Float Double Boolean 简单来说，装箱就是基本类型转换为对象类型，拆箱就是对象类型转换为基本类型。 通常情况下如果我们要创建一个对象，需要new关键字。 1Integer i = new Integer(10); 自动装箱就是Java会自动完成基本类型到包装类型的转换。 12Integer i = 10;//装箱int j = i;//拆箱 2. 如何实现以Integer为例。 1234567public class Main &#123; public static void main(String[] args) &#123; Integer i = 10; int n = i; &#125; &#125; 反编译class文件： 可知，在装箱调用的是Integer的valueOf()方法，拆箱调用的是Integer的intValue()方法。 3. 判断相等对于下面代码 12345678Integer i1 = 100;Integer i2 = 100;Integer i3 = 200;Integer i4 = 200;System.out.println(i1 == i2);//trueSystem.out.println(i3 == i4);//falseSystem.out.println(i1.equals(i2));//trueSystem.out.println(i3.equals(i4));//true 输出不同的原因是因为缓存池的存在。具体在之前有说过。 Java基础2：基本数据类型 4. 类型转换对于下面代码 12short s1 += 1;//可以正常编译通过short s1 = s1 + 1;//无法正常编译通过 对于第一种情况，Java在运算 +=，-=，*=，/= 等运算符时会自动进行类型的转换。 对于第二种情况，s1为short类型，s1 + 1为int类型，不能向下转型，所以报错。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java并发之CLH同步队列","date":"2018-11-07T16:39:33.000Z","path":"2018/11/08/Java并发之CLH同步队列/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java并发之AQS","date":"2018-11-07T16:38:58.000Z","path":"2018/11/08/Java并发之AQS/","text":"Java的内置锁一直都是备受争议的，在JDK 1.6之前，synchronized这个重量级锁其性能一直都是较为低下，虽然在1.6后，进行大量的锁优化策略(Java并发之synchronized原理),但是与Lock相比synchronized还是存在一些缺陷的：虽然synchronized提供了便捷性的隐式获取锁释放锁机制（基于JVM机制），但是它却缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，且它为独占式在高并发场景下性能大打折扣。 在介绍Lock之前，我们需要先熟悉一个非常重要的组件，掌握了该组件JUC包下面很多问题都不在是问题了。该组件就是AQS。 AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。 AQS解决了子啊实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。 AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。 AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。 AQS主要提供了如下一些方法： getState()：返回同步状态的当前值； setState(int newState)：设置当前同步状态； compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性； tryAcquire(int arg)：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态； tryRelease(int arg)：独占式释放同步状态； tryAcquireShared(int arg)：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败； tryReleaseShared(int arg)：共享式释放同步状态； isHeldExclusively()：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占； acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法； acquireInterruptibly(int arg)：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回； tryAcquireNanos(int arg,long nanos)：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true； acquireShared(int arg)：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态； acquireSharedInterruptibly(int arg)：共享式获取同步状态，响应中断； tryAcquireSharedNanos(int arg, long nanosTimeout)：共享式获取同步状态，增加超时限制； release(int arg)：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒； releaseShared(int arg)：共享式释放同步状态； 转自 死磕Java并发之A.Q.S简介","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java并发之Java内存模型","date":"2018-11-07T16:38:32.000Z","path":"2018/11/08/Java并发之Java内存模型/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java并发之volatile原理","date":"2018-11-06T12:32:20.000Z","path":"2018/11/06/Java并发之volatile原理/","text":"虽然synchronized可以保证并发时的原子性，有序性和可见性，但是由于它本身是一个重量级锁，尽管JVM对它进行了优化，但是在线程上下文切换时仍然难以确保很好的效率。此外，面对着大多数业务场景下都不会发生多线程并发的时候，使用synchronized未免有些奢侈。对于volatile关键字，它的使用成本比synchronized低很多，因为它不会引起线程上下文的切换。Java语言规范对volatile的定义如下： Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。 直白地说，如果一个变量被volatile修饰，Java可以确保它的可见性和有序性，但不能保证对于它操作的原子性。即，虚拟机只是保证从主内存加载到线程内存的值永远是最新的。 1. 操作系统语义计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中涉及到数据的读写。为了匹配cpu运行速度和主存速度的不一致性，引入了CPU高速缓存。CPU高速缓存为某个CPU所独有，只与在该CPU运行的线程有关。 带来的问题：数据的一致性 例如：对于 1i++; 如果有两个线程同时执行这段代码，首先会将i的初始值读到各自的缓存中再进行自增操作。之后再将自增后的值写回到主内存中。这样带来的问题是最后i只自增了一次。 解决缓存一致性的方法有： 通过在总线加LOCK#锁的方式 通过缓存一致性协议 方案一是通过一种独占式的方式来实现，在总线加LOCK#锁的话，只能有一个CPU能够执行，其他CPU处于阻塞状态，效率较低。 方案二，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。 2. Java内存模型详见之后文章。 1. 原子性即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double）。要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。 volatile是无法保证复合操作的原子性 2. 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。 Java提供了volatile来保证可见性。 当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。当然，synchronize和锁都可以保证可见性。 3. 有序性在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。 Java提供volatile来保证一定的有序性。 3. volatile原理1. LOCK#前缀指令（可见性） 将当前处理器缓存行的数据写回到系统内存。 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。 如果对声明了volatile的变量进行操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回内存如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。 所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里 。 lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。 2. happens before原则（有序性）在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序： 编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； 处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序； 指令重排序对单线程没有什么影响，他不会影响程序的运行结果，但是会影响多线程的正确性。既然指令重排序会影响到多线程执行的正确性，那么我们就需要禁止重排序。那么JVM是如何禁止重排序的呢？这个问题稍后回答，我们先看另一个原则happens-before，happen-before原则保证了程序的“有序性”，它规定如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。其定义如下： 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则） 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则） 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则） 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。 12345678910111213141516class VolatileExample &#123; int a = 0; volatile boolean flag = false; public void writer() &#123; a = 1; //1 flag = true; //2 &#125; public void reader() &#123; if (flag) &#123; //3 int i = a; //4 …… &#125; &#125;&#125; 如果一个线程执行writer,一个线程执行reader 根据程序执行次序,1 happens before 2,3 happens before 4 根据volatile原则，2 happens before 3 根据传递性，1 happens before 4 3. 内存屏障（禁止特定类型的处理器重排序）为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略： 在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。 上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java并发之synchronized原理","date":"2018-11-06T12:31:44.000Z","path":"2018/11/06/Java并发之synchronized原理/","text":"1. 前言synchronized在Java中似乎是一个很神秘的关键字，很多同学都知道在多线程情况下synchronized是处理并发问题的良药，但却不知道它的原理是怎样的。所以，一开始就要从它的实现原理看起。 2. 实现原理2.1 synchronized用法synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 普通同步方法，锁是当前实例对象 静态同步方法，锁是当前类的class对象 同步方法块，锁是括号里面的对象 当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码： 1234567891011public class SynchronizedTest &#123; public synchronized void test1()&#123; &#125; public void test2()&#123; synchronized (this)&#123; &#125; &#125;&#125; 利用javap工具查看生成的class文件信息来分析Synchronize的实现 会发现，synchronized是利用JVM的监视器锁，在需要同步的代码块前后加上monitorenter和moniterexit指令实现的。 对于同步方法的实现是依靠方法修饰符上的ACC_SYNCHRONIZED实现的。 2.2 同步代码块monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁； 2.3 同步方法synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。 2.4 对象头synchronized用的锁是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述Mark Word。 Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。下图是Java对象头的存储结构（32位虚拟机）： 2.5 Monitor什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。 与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。 Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下： Monitor Record Owner EntryQ RcThis Nest HashCode Candidate Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。Nest:用来实现重入锁的计数。HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。 3. 锁优化jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 3.1 自旋锁线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。何谓自旋锁？所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。 3.2 适应自旋锁JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。 3.3 锁消除为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法： 12345678public void vectorTest()&#123; Vector&lt;String&gt; vector = new Vector&lt;String&gt;(); for(int i = 0 ; i &lt; 10 ; i++)&#123; vector.add(i + \"\"); &#125; System.out.println(vector); &#125; 在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。 3.4 锁粗化我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。 3.5 轻量级锁引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： 获取锁 判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）； JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）； 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态； 释放锁轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： 取出在获取轻量级锁保存在Displaced Mark Word中的数据； 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）； 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。 对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢； 下图是轻量级锁的获取和释放过程 3.6 偏向锁引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：获取锁 检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01； 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）； 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）； 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块； 执行同步代码块 释放锁偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下： 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态； 撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态； 3.7 重量级锁重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。 4. 不同锁的比较 5. 参考 《Java并发编程的艺术》 死磕并发 Java中synchronized的实现原理与应用","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"SpringBoot学习7：数据访问","date":"2018-11-06T12:00:53.000Z","path":"2018/11/06/SpringBoot学习7：数据访问/","text":"一、数据访问1、整合JDBC数据源1、新建项目 spring-boot-06-data-jdbc WEB Mysql JDBC SpringBoot1.5 2、编写配置文件appliction.yml 123456spring: datasource: username: root password: Welcome_1 url: jdbc:mysql://192.168.179.131:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 3、编写测试类测试 1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot06DataJdbcApplicationTests &#123; @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125; 4、测试结果 12class org.apache.tomcat.jdbc.pool.DataSourceProxyConnection[PooledConnection[com.mysql.jdbc.JDBC4Connection@c35af2a]] 数据源相关配置都在DataSourceProperties属性里 自动配置原理 E:\\Develop\\Maven_Repo\\org\\springframework\\boot\\spring-boot-autoconfigure\\1.5.13.RELEASE\\spring-boot-autoconfigure-1.5.13.RELEASE.jar!\\org\\springframework\\boot\\autoconfigure\\jdbc 1、DataSource参考DataSourceConfiguration,根据配置创建数据源，默认是使用tomcat连接池，可以使用spring.datasource.type指定自定义的数据源 2、SpringBoot默认支持1234Tomcat数据源HikariDataSourcedbcp.BasicDataSourcedbcp2.BasicDataSource 3、自定义数据源123456789101112 */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = \"spring.datasource.type\")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用builder创建数据源，利用反射创建相应的type数据源，并绑定数据源 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、运行sql建表在DataSourceAutoConfiguration中DataSourceInitializer类 监听器 作用： 1）、postConstruct -》runSchemaScript 运行建表sql文件 2）、runDataScript运行插入数据的sql语句； 默认只需要将文件命名为： 12schema-*.sql data-*.sql默认规则：schema.sql ,schema-all.sql; 举个栗子 创建department表 1、department.sql 1234567891011121314151617181920212223242526/*Navicat MySQL Data TransferSource Server : 192.168.179.131Source Server Version : 50719Source Host : 192.168.179.131:3306Source Database : jdbcTarget Server Type : MYSQLTarget Server Version : 50719File Encoding : 65001Date: 2018-05-14 14:28:52*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) DEFAULT '', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2、将department.sql命名为schema-all.sql 3、运行测试类 自定义sql的文件名，department.sql在配置文件中 12schema: - classpath:department.sql 5、操作JdbcTemplateFBI warning:将department.sql删除或者改名，因为运行文件会将表中数据清除 1、新建一个Controller 1234567891011121314@Controllerpublic class HelloController &#123; @Autowired JdbcTemplate jdbcTemplate; @ResponseBody @GetMapping(\"/hello\") public Map&lt;String ,Object&gt; hello()&#123; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(\"select * from department\"); return list.get(0); &#125;&#125; 2、表中添加数据 3、访问请求查询数据 2、自定义数据源1、导入Druid的依赖 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt; 2、修改配置文件 1234567891011spring: datasource: username: root password: Welcome_1 url: jdbc:mysql://192.168.179.131:3306/jdbc driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource# schema:# - classpath:department.sqlserver: port: 9000 已经替换了原来的tomcat数据源 3、配置Druid数据源配置 1234567891011121314151617181920212223242526272829303132spring: datasource: username: root password: Welcome_1 url: jdbc:mysql://192.168.179.131:3306/jdbc driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 初始化大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters,去掉监控界面sql无法统计，‘wall’用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 userGlobalDataSourceStat: true # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# schema:# - classpath:department.sqlserver: port: 9000 4、Druid配置监控 12345678910111213141516171819202122232425262728293031323334@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台 @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),\"/druid/*\"); Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;(); initParams.put(\"loginUsername\", \"admin\"); initParams.put(\"loginPassword\", \"123456\"); bean.setInitParameters(initParams); return bean; &#125; //2、配置监控的filter @Bean public FilterRegistrationBean webstatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;(); initParams.put(\"exclusions\", \"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 5、运行测试，访问 localhost:9000/druid 输入刚才调好的用户名密码即可访问 3、整合Mybatis1、新建工程，SpringBoot1.5+web+JDBC+Mysql 导入依赖 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 2、导入配置文件中关于Druid的配置 ​ 2.1、导入依赖 ​ 2.2、配置文件application.yml（指定用户名密码…配置Druid的配置参数，修改sql文件加载的默认名） ​ 2.3、将Druid组件加入到容器中（监控）重点 ​ 具体同上 3、创建数据表department和employee表 ​ 3.1、根据sql文件，新建两张表 ​ 3.2、修改加载的sql名（默认为schema.sql和schema-all.sql） 12345spring: datasource: schema: - classpath:sql/department.sql - classpath:sql/employeee.sql ​ 3.3、运行程序检查数据库是否创建成功 4、创建数据库对应的JavaBean （驼峰命名，getter/setter toString/注释掉schema防止重复创建） 在配置文件中修改驼峰命名开启 ,不写配置文件就写配置类 123mybatis: configuration: map-underscore-to-camel-case: true 123456789101112131415//类名冲突所以全类名@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer() &#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 注解方式5、新建mapper 1234567891011121314151617//指定是一个mapper@Mapperpublic interface DepartmentMapper &#123; @Insert(\"insert into department(dept_name) value(#&#123;deptName&#125;)\") public int insertDept(Department department); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id); @Update(\"update department set dept_Name=#&#123;deptName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department); @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id);&#125; 6、编写controller测试 1234567891011121314151617181920212223242526@RestControllerpublic class DeptController &#123; @Autowired DepartmentMapper departmentMapper; @RequestMapping(\"/getDept/&#123;id&#125;\") public Department getDepartment(@PathVariable(\"id\") Integer id)&#123; return departmentMapper.getDeptById(id); &#125; @RequestMapping(\"/delDept/&#123;id&#125;\") public int delDept(@PathVariable(\"id\") Integer id)&#123; return departmentMapper.deleteDeptById(id); &#125; @RequestMapping(\"/update/&#123;id&#125;\") public int updateDept(@PathVariable(\"id\") Integer id)&#123; return departmentMapper.updateDept(new Department(id, \"开发部\")); &#125; @GetMapping(\"/insert\") public int insertDept(Department department)&#123; return departmentMapper.insertDept(department); &#125;&#125; 问题： mapper文件夹下有多个mapper文件，加麻烦，可以直接扫描整个mapper文 件夹下的mapper 12//主配置类或者mybatis配置类@MapperScan(value = \"com.wdjr.springboot.mapper\") 配置文件方式1、新建文件 2、新建mybatis的配置文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 3、新建Employee的接口方法 123456public interface EmployeeMapper &#123; public Employee getEmpById(Integer id); public void insetEmp(Employee employee);&#125; 4、新建Employee的mapper.xml的映射文件 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wdjr.springboot.mapper.EmployeeMapper\"&gt; &lt;select id=\"getEmpById\" resultType=\"com.wdjr.springboot.bean.Employee\"&gt; select * from employee where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=\"insetEmp\"&gt; INSERT INTO employee(last_name,email,gender,d_id) VALUES (#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;) &lt;/insert&gt;&lt;/mapper&gt; 5、修改application.yml配置文件 123mybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml 6、新建一个Controller访问方法 12345678910111213141516@RestControllerpublic class EmployeeController &#123; @Autowired EmployeeMapper employeeMapper; @RequestMapping(\"/getEmp/&#123;id&#125;\") public Employee getEmp(@PathVariable(\"id\") Integer id)&#123; return employeeMapper.getEmpById(id); &#125; @GetMapping(\"/insertEmp\") public Employee insertEmp(Employee employee)&#123; employeeMapper.insetEmp(employee); return employee; &#125;&#125; 4、JPA数据访问新建工程 springBoot1.5+Web+JPA+MYSQL+JDBC 目录结构 1、新建一个实体类User 123456789101112131415161718192021222324252627282930313233343536373839//使用JPA注解配置映射关系@Entity//告诉JPA这是一个实体类（和数据表映射的类）@Table(name=\"tbl_user\") //@Table来指定和那个数据表对应，如果省略默认表明就是user;public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增组件 private Integer id ; @Column(name=\"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column//省略默认列名就是属性名 private String email; @Column public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; 2、新建一个UserRepository来继承jpa的绝大多数功能 1234//继承jpaRepositorypublic interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3、编写配置文件application.yml 1234567891011spring: datasource: url: jdbc:mysql://192.168.179.131/jpa username: root password: Welcome_1 driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: #更新或创建 ddl-auto: update show-sql: true 4、编写Controller测试 1234567891011121314151617@RestControllerpublic class UserController &#123; @Autowired UserRepository userRepository; @GetMapping(\"/user/&#123;id&#125;\") public User getUser(@PathVariable(\"id\") Integer id)&#123; User user = userRepository.findOne(id); return user; &#125; @GetMapping(\"/insert\") public User insertUser(User user)&#123; User user1 = userRepository.save(user); return user1; &#125;&#125; #","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"},{"name":"Jpa","slug":"Jpa","permalink":"http://yoursite.com/tags/Jpa/"},{"name":"JdbcTemplate","slug":"JdbcTemplate","permalink":"http://yoursite.com/tags/JdbcTemplate/"}]},{"title":"SpringBoot学习6：Docker","date":"2018-11-06T12:00:30.000Z","path":"2018/11/06/SpringBoot学习6：Docker/","text":"一、Docker1、简介Docker是一个开源的应用容器引擎 将软件编译成一个镜像；然后在镜像里各种软件做好配置，将镜像发布出去，其他的使用这就可以直接使用这个镜像。运行中的这个镜像叫做容器，容器启动速度快，类似ghost操作系统，安装好了什么都有了； 2、Docker的核心概念docker主机（HOST）:安装了Docker程序的机器（Docker直接安装在操作系统上的） docker客户端（Client）:操作docker主机 docker仓库（Registry）：用来保存打包好的软件镜像 docker镜像（Image）:软件打好包的镜像，放到docker的仓库中 docker容器（Container）:镜像启动后的实例（5个容器启动5次镜像） docker的步骤： ​ 1、安装Docker ​ 2、去Docker仓库找到这个软件对应的镜像； ​ 3、使用Docker运行的这个镜像，镜像就会生成一个容器 ​ 4、对容器的启动停止，就是对软件的启动和停止 3、安装Docker1、安装Linux安装vxbox并且安装ubuntu 2、在linux上安装docker1234567891011121314151、查看centos版本# uname -r3.10.0-693.el7.x86_64要求：大于3.10如果小于的话升级*（选做）# yum update2、安装docker# yum install docker3、启动docker# systemctl start docker# docker -v4、开机启动docker# systemctl enable docker5、停止docker# systemctl stop docker 4、docker的常用操作1、镜像操作1、搜索 1docker search mysql 默认去docker hub网站查找 2、拉取 1234默认最新版本# docekr pull mysql安装指定版本# docker pull mysql:5.5 3、查看 1docker images 4、删除 1docker rmi imageid 2、容器操作软件的镜像（qq.exe） – 运行镜像 – 产生一个容器（正在运行的软件） 1234567891011121314151617181920212223242526272829303132333435363738391、搜索镜像# docker search tomcat2、拉取镜像# docker pull tomcat3、根据镜像启动容器[root@lion ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest d3d38d61e402 35 hours ago 549 MB[root@lion ~]# docker run --name mytomcat -d tomcat:latest2f0348702f5f2a2777082198795d8059d83e5ee38f430d2d44199939cc63e2494、查看那个进程正在进行[root@lion ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2f0348702f5f tomcat:latest \"catalina.sh run\" 41 seconds ago Up 39 seconds 8080/tcp mytomcat5、停止运行中容器[root@lion ~]# docker stop 2f0348702f5f2f0348702f5f6、查看所有容器[root@lion ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2f0348702f5f tomcat:latest \"catalina.sh run\" 52 minutes ago Exited (143) 2 minutes ago mytomcat7、启动容器[root@lion ~]# docker start 2f0348702f5f8、删除docker容器[root@lion ~]# docker rm 2f0348702f5f2f0348702f5f9、端口映射[root@lion ~]# docker run --name mytomcat -d -p 8888:8080 tomcat692c408c220128014df32ecb6324fb388427d1ecd0ec56325580135c58f63b29虚拟机:8888容器的:8080-d:后台运行-p:主机端口映射到容器端口浏览器：192.168.179.129:888810、docker的日志[root@lion ~]# docker logs 692c408c220111、多个启动[root@lion ~]# docker run -d -p 9000:8080 --name mytomcat2 tomcat浏览器：192.168.179.129:9000 更多命令参考docker镜像文档 3、安装Mysql12docker pull mysqldocker run --name mysql001 -e MYSQL_ROOT_PASSWORD -d -p 3307:3306 mysql #","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"SpringBoot学习5：web开发","date":"2018-11-06T12:00:11.000Z","path":"2018/11/06/SpringBoot学习5：web开发/","text":"一、web开发1、简介使用SpringBoot; 1)、创建SpringBoot应用，选中我们需要的模块； 2)、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3)、自己编写业务代码 自动配置原理？ 这个场景的SpringBoot帮我们配置了什么？能不能修改？能修改那些配置？能不能扩展？xxx 12xxxAutoConfiguration:帮我们给容器中自动配置组件xxxProperties:配置类来封装配置文件的内容 2、静态资源文件映射规则123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware, InitializingBean &#123; //可以设置和静态资源相关的参数，缓存时间等 12345678910111213141516171819202122@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration(registry .addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125;&#125; 1、webjar1)、所有的/webjars/**，都去classpath:/META-INF/resources/webjars/找资源； ​ webjars：以jar包的方式引入静态资源 http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 2、本地资源1private String staticPathPattern = &quot;/**&quot;; 访问任何资源 2、会在这几文件夹下去找静态路径（静态资源文件夹） 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;,&quot;/&quot;;当前项目的根路径 localhost:8080/abc ==&gt;去静态资源文件夹中找abc 3、index页面欢迎页，静态资源文件夹下所有的index.html页面；被“/**”映射； localhost:8080/ –&gt;index页面 123456@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125; 4、喜欢的图标，即网站title的图标favicon 1234567891011121314151617181920212223242526272829@Configuration@ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true)public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //把任何favicon的图标都在静态文件夹下找 mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125;&#125; 可以在配置文件配置静态资源文件夹 1spring.resources.static-locations=classpath:xxxx 3、模板引擎将html和数据 结合到一起 输出组装处理好的新文件 SpringBoot推荐Thymeleaf;语法简单，功能强大 1、引入thymeleaf 31234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 默认导入thymeleaf2，版本太低 所以使用thymeleaf3. 官方导入办法 12345678910&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--thymeleaf 3的导入--&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!--布局功能支持 同时支持thymeleaf3主程序 layout2.0以上版本 --&gt; &lt;!--布局功能支持 同时支持thymeleaf2主程序 layout1.0以上版本 --&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 2、Thymeleaf使用和语法1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; //只要把HTML文件方法类路径下的template文件夹下，就会自动导入 只要把HTML页面放到classpath:/templates/,thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;success&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success&lt;/h1&gt;&lt;!--th:text 将div里面的文本内容设置为--&gt;&lt;div th:text=\"$&#123;Lion&#125;\"&gt;前端数据&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则 1）、th:text=”${hello}”可以使用任意标签 替换原生的任何属性 在SpringBoot的环境下 123&lt;div id=\"testid\" class=\"testcalss\" th:id=\"$&#123;Lion&#125;\" th:class=\"$&#123;Lion&#125;\" th:text=\"$&#123;Lion&#125;\"&gt; 前端数据&lt;/div&gt; 直接访问HTML页面 2)、内联写法注意需要在body上加上 th:inline=”text”敲黑板 不然不起作用 1&lt;body class=\"text-center\" th:inline=\"text\"&gt;&lt;/body&gt; th标签的访问优先级 Order Feature Attributes 3、语法规则 功能 标签 功能和jsp对比 1 Fragment inclusion th:insert th:replace include(片段包含) 2 Fragment iteration th:each c:forEach(遍历) 3 Conditional evaluation th:if th:unless th:switch th:case c:if(条件判断) 4 Local variable definition th:object th:with c:set(声明变量) 5 General attribute modification th:attr th:attrprepend th:attrappend 属性修改支持前面和后面追加内容 6 Specific attribute modification th:value th:href th:src … 修改任意属性值 7 Text (tag body modification) th:text th:utext 修改标签体内容utext：不转义字符大标题 8 Fragment specification th:fragment 声明片段 9 Fragment removal th:remove 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Simple expressions:(表达式语法) Variable Expressions: $&#123;...&#125; 1、获取对象属性、调用方法 2、使用内置基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3、内置一些工具对象 #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125; //选择表达式：和$&#123;&#125;功能一样，补充功能 # 配合th:object使用，object=$&#123;object&#125; 以后获取就可以使用*&#123;a&#125; 相当于$&#123;object.a&#125; &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125; //获取国际化内容 Link URL Expressions: @&#123;...&#125; //定义URL链接 #&lt;a href=&quot;details.html&quot; th:href=&quot;@&#123;/order/details(orderId=$&#123;o.id&#125;)&#125;&quot;&gt;view&lt;/a&gt; Fragment Expressions: ~&#123;...&#125;//片段文档 Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:(文本操作) String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:（条件运算） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens:（空操作） No-Operation: _ inline写法 12[[]] --&gt;th:text[()] --&gt;th:utext 4、SpringMVC自动配置1、SpringMVC的自动导入Spring框架 自动配置好了mvc： 以下是SpringBoot对SpringMVC的默认 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver(视图解析器：根据方法的返回值得到视图对象（View）,视图对象决定如何渲染（转发？重定向？）) ContentNegotiatingViewResolver组合所有视图解析器 如何定制：我们可以自己给容器中添加一个视图解析器；自动将其整合进来 Support for serving static resources, including support for WebJars (see below).静态资源 Static index.html support. Custom Favicon support (see below). 自动注册 了Converter, GenericConverter, Formatter beans. Converter：类型转换 文本转为字面量 Formatter ：格式化器 转换后格式转换 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件配置入职格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; 自己添加的格式化转换器，只需要放在容器中即可 Support for HttpMessageConverters (see below). HttpMessageConverters ：转换HTTP转换和响应：User - json HttpMessageConverters ：是从容器中确定；获取所有的HttpMessageConverters ，将自己的组件注册在容器中@Bean If you need to add or customize converters you can use Spring Boot’s HttpMessageConverters class: 123456789101112131415import org.springframework.boot.autoconfigure.web.HttpMessageConverters;import org.springframework.context.annotation.*;import org.springframework.http.converter.*;@Configurationpublic class MyConfiguration &#123; @Bean public HttpMessageConverters customConverters() &#123; HttpMessageConverter&lt;?&gt; additional = ... HttpMessageConverter&lt;?&gt; another = ... return new HttpMessageConverters(additional, another); &#125;&#125; Automatic registration of MessageCodesResolver (see below). 定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). 123456789@Overrideprotected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() &#123; try &#123; return this.beanFactory.getBean(ConfigurableWebBindingInitializer.class); &#125; catch (NoSuchBeanDefinitionException ex) &#123; return super.getConfigurableWebBindingInitializer(); &#125;&#125; 在beanFactory：中可以自己创建一个，初始化webDataBinder 请求数据 ==》javaBean If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 思想：修改默认配置 2、扩展SpringMVC编写一个配置类，类型是WebMvcConfigurerAdapter(继承)，使用WebMvcConfigurerAdapter可以扩展，不能标注@EnableWebMvc;既保留了配置，也能拓展我们自己的应用 12345678910@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// super.addViewControllers(registry); //浏览器发送wdjr请求，也来到success页面 registry.addViewController(\"/wdjr\").setViewName(\"success\"); &#125;&#125; 原理： 1）、WebMvcAutoConfiguration是SpringMVC的自动配置 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 1234567891011121314151617181920212223@Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有webMVCconfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); @Override protected void addViewControllers(ViewControllerRegistry registry) &#123; this.configurers.addViewControllers(registry); &#125; //一个参考实现,将所有的webMVCconfigurer相关配置一起调用（包括自己的配置类） @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; //delegate.addViewControllers(registry); //&#125; &#125; &#125; &#125; 3）、自己的配置被调用 效果：SpringMVC的自动配置和我们的扩展配置都会起作用 3、全面接管mvc不需要SpringBoot对SpringMVC的自动配置。 12345678910111213@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123;@Overridepublic void addViewControllers(ViewControllerRegistry registry) &#123;// super.addViewControllers(registry); //浏览器发送wdjr请求，也来到success页面 registry.addViewController(\"/wdjr\").setViewName(\"success\"); &#125;&#125; 例如静态资源访问，不推荐全面接管 原理： 为什么@EnableWebMvc注解，SpringBoot对SpringMVC的控制就失效了 1）、核心配置 123@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; 2）、DelegatingWebMvcConfiguration 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、WebMvcAutoConfiguration 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport导入进来了； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能 5、修改SpringMVC默认配置模式: ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有 xxxConfigurer帮助我们扩展配置。 6、RestfulCRUD1、默认访问首页在config/MyConfig.java中编写配置类 123456789101112//所有的webMvcConfigurerAdapter组件会一起起作用@Bean //註冊到容器去public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/login.html\").setViewName(\"login\"); &#125; &#125;; return adapter;&#125; 静态资源引用 1&lt;link href=\"#\" th:href=\"@&#123;/css/signin.css&#125;\" rel=\"stylesheet\" /&gt; 2、国际化1、编写国际化配置文件 2、使用ResourceBundleMessageSource管理国际化资源文件 3、在页面中使用fmt:message，取出国际化内容 1、浏览器切换国际化步骤 1、编写国际化配置文件，抽取页面需要的显示的国际化消息 2、SpringBoot自动配置好了国际化配置的资源文件 1234567891011121314151617181920@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration &#123; //我们的配置文件可以直接放在类路径下叫messages.properties private String basename = \"messages\"; @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化文件的基础名，去掉语言国家代码 messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3、对IDEA的编码进行设置 4、login进行标签插入 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0051)https://getbootstrap.com/docs/4.1/examples/sign-in/ --&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\" /&gt; &lt;meta name=\"description\" content=\"\" /&gt; &lt;meta name=\"author\" content=\"\" /&gt; &lt;link rel=\"icon\" href=\"https://getbootstrap.com/favicon.ico\" /&gt; &lt;title&gt;登录页面&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"#\" th:href=\"@&#123;/css/bootstrap.min.css&#125;\" rel=\"stylesheet\" /&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"./login_files/signin.css\" th:href=\"@&#123;/css/signin.css&#125;\" rel=\"stylesheet\" /&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\"&gt; &lt;img class=\"mb-4\" src=\"./login_files/bootstrap-solid.svg\" th:src=\"@&#123;/img/bootstrap-solid.svg&#125;\" alt=\"\" width=\"72\" height=\"72\" /&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"/&gt; &lt;label for=\"inputPassword\" class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"inputPassword\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\" /&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\" /&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果根据浏览器语言的信息切换国际化 原理： 国际化locale（区域信息对象）；LocaleResolver(获取区域对象)； 123456789101112@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\")public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125; 默认的就是根据请求头带来的区域信息获取local国际化信息（截图就是这么犀利） 2、点击链接切换国际化自己编写localResolver，加到容器中 1、更改HTML代码 123&lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a href=\"#\" class=\"btn btn-sm\" th:href=\"@&#123;/index.html?lg=zh_CN&#125;\"&gt;中文&lt;/a&gt; &lt;a href=\"#\" class=\"btn btn-sm\" th:href=\"@&#123;/index.html?lg=en_US&#125;\"&gt;English&lt;/a&gt; 2、新建一个MyLocaleResolver.class 12345678910111213141516171819public class MyLocaleResolver implements LocaleResolver &#123; //解析区域信息 @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(\"lg\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(\"_\"); locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; 3、将MyLocaleResolver加入到容器中 1234@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocalResolver();&#125; 4、启动演示 3、登录拦截器1、登录开发技巧 ​ 1、清除模板缓存 ​ 2、Ctrl+F9刷新 1、新建一个LoginController 1234567891011121314151617@Controllerpublic class LoginController &#123; @PostMapping(value =\"/user/login\") public String login(@RequestParam(\"username\")String username, @RequestParam(\"password\")String password, Map&lt;String,Object&gt; map)&#123; if(!StringUtils.isEmpty(username) &amp;&amp; \"123456\".equals(password))&#123; //登录成功 return \"list\"; &#125;else&#123; map.put(\"msg\", \"用户名密码错误\"); return \"login\"; &#125; &#125;&#125; 2、登录错误消息显示 12&lt;!--判断--&gt;&lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 3、表单重复提交 表单重复提交事件 –》重定向来到成功页面–》模板引擎解析 1234567if(!StringUtils.isEmpty(username) &amp;&amp; \"123456\".equals(password))&#123; //登录成功,防止重复提交 return \"redirect:/main.html\";&#125;else&#123; map.put(\"msg\", \"用户名密码错误\"); return \"login\";&#125; 模板引擎解析 123456@Overridepublic void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"Dashboard\");&#125; 4、拦截器作用：实现权限控制，每个页面请求前中后，都会进入到拦截器进行处理（登录权限） 1、在component下新建一个LoginHandlerInterceptor拦截器 123456789101112131415161718192021222324252627public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user!=null)&#123; //已经登录 return true; &#125; //未经过验证 request.setAttribute(\"msg\", \"没权限请先登录\"); request.getRequestDispatcher(\"/index.html\").forward(request, response); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 2、在MyMvcConfig配置中重写拦截器方法，加入到容器中 1234567891011121314151617181920//所有的webMvcConfigurerAdapter组件会一起起作用@Bean //註冊到容器去public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"Dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //静态资源 css js img 已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\"). excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter;&#125; 3、在LoginHandler中添加登录成功写入session 12345678910111213141516171819@Controllerpublic class LoginController &#123; @PostMapping(value =\"/user/login\") public String login(@RequestParam(\"username\")String username, @RequestParam(\"password\")String password, Map&lt;String,Object&gt; map, HttpSession session)&#123; if(!StringUtils.isEmpty(username) &amp;&amp; \"123456\".equals(password))&#123; //登录成功,防止重复提交 session.setAttribute(\"loginUser\", username); return \"redirect:/main.html\"; &#125;else&#123; map.put(\"msg\", \"用户名密码错误\"); return \"login\"; &#125; &#125;&#125; 5、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格 URI:/资源名称/资源标识+HTTP操作 普通CRUD RestfulCRUD 查询 getEmp emp – GET 添加 addEmp?xxx emp –POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id} – PUT 删除 deleteEmp?id=1 emp/{id} –DELETE 2、实验的请求架构 请求URI 请求方式 查询所有员工 emps GET 查询某个员工 emp/{id} GET 添加页面 emp GET 添加员工 emp POST 修改页面(回显) emp/{id} GET 修改员工 emp/{id} PUT 删除员工 emp/{id} DELETE 3、员工列表 1、公共页面抽取使用方法 1234567891、抽取公共片段&lt;!--footer.html--&gt;&lt;div id=\"footid\" th:fragment=\"copy\"&gt;xxx&lt;/div&gt;2、引入公共片段&lt;!--test.html--&gt;&lt;div th:insert=~&#123;footer::copy&#125;&gt;&lt;/div&gt;~&#123;templatename::selector&#125; 模板名::选择器 footer::#footid~&#123;templatename::fragmentname&#125; 模板名::片段名称 footer::copy行内写法可以加~&#123;xx::xx&#125; 标签体可以 xx::xx 三种引用方式 th:insert :加个外层标签 +1 th:replace :完全替换 1 th:include：就替换里面的内容 -1 公共页面 123456&lt;body&gt; ... &lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;&lt;/body&gt; 结果 1234567891011121314151617&lt;body&gt;... &lt;!-- th:insert --&gt; &lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt; &lt;/div&gt; &lt;!--th:replace--&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt; &lt;!--th:include--&gt; &lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/div&gt;&lt;/body&gt; 用此种方法将公共页面引入 2、列表高亮引入片段的时候传入参数，新建一个commons文件夹存储公共页面bar.html 模板引入变量名 dashboard 123456&lt;a class=\"nav-link active\" th:class=\"$&#123;activeUri&#125;=='main.html'?'nav-link active':'nav-link'\" href=\"https://getbootstrap.com/docs/4.1/examples/dashboard/#\" th:href=\"@&#123;/main.html&#125;\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt;&lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt;&lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt;&lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt; 员工管理 1234567&lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" th:class=\"$&#123;activeUri&#125;=='emps'?'nav-link active':'nav-link'\" href=\"https://getbootstrap.com/docs/4.1/examples/dashboard/#\" th:href=\"@&#123;/emps&#125;\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-users\"&gt;&lt;path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"&gt;&lt;/path&gt;&lt;circle cx=\"9\" cy=\"7\" r=\"4\"&gt;&lt;/circle&gt;&lt;path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"&gt;&lt;/path&gt;&lt;path d=\"M16 3.13a4 4 0 0 1 0 7.75\"&gt;&lt;/path&gt;&lt;/svg&gt; 员工管理 &lt;/a&gt; 引入模板的时候传入参数 dashboard.html引入 12&lt;!--引入侧边栏--&gt; &lt;div th:replace=\"commons/bar :: sidebar(activeUri='main.html')\"&gt;&lt;/div&gt; list.html引入 12&lt;!--引入侧边栏--&gt;&lt;div th:replace=\"commons/bar::sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6、列表数据显示（查）1、传入员工对象EmployeeController类,传入员工对象 12345678910111213141516@Controllerpublic class EmployeeController &#123; @Autowired EmployeeDao employeeDao; /** * 查询所有员工返回列表页面 */ @GetMapping(value = \"/emps\") public String list(Model model)&#123; Collection&lt;Employee&gt; employees = employeeDao.getAll(); model.addAttribute(\"emps\",employees); return \"emp/list\"; &#125;&#125; 2、 遍历对象list.html中 使用模板的 th:each方法 123456789101112131415161718192021222324252627table class=\"table table-striped table-sm\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;department&lt;/th&gt; &lt;th&gt;birth&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"emp:$&#123;emps&#125;\"&gt; &lt;td th:text=\"$&#123;emp.id&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;emp.lastName&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;emp.email&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;emp.gender&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;emp.department.departmentName&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')&#125;\"&gt;1&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-sm btn-primary\"&gt;编辑&lt;/button&gt; &lt;button class=\"btn btn-sm btn-danger\"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 3、效果显示 7、员工添加（增）功能：点击添加按钮，出现新增页面 1、新增页面12345678910111213141516171819202122232425262728293031323334353637&lt;form&gt; &lt;!-- LastName --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"LastName\"&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"LastName\" placeholder=\"LastName\"&gt; &lt;/div&gt; &lt;!-- Email --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"Email\"&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"Email\" placeholder=\"zhangsan@163.com\"&gt; &lt;/div&gt; &lt;!--gender--&gt; &lt;div class=\"form-group\"&gt; &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\" &gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\" &gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- department --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleFormControlSelect1\"&gt;department&lt;/label&gt; &lt;select class=\"form-control\" id=\"exampleFormControlSelect1\"&gt; &lt;option th:each=\"dept:$&#123;depts&#125;\" th:value=\"$&#123;dept.id&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;!--Birth--&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"birthDate\"&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"birthDate\" placeholder=\"2012-12-12\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添 加&lt;/button&gt;&lt;/form&gt; 2、页面跳转在EmployeeController中添加addEmpPage方法 12345678910/** * 添加员工 */@GetMapping(value = \"/emp\")public String toAddPage(Model model)&#123; //来到添加页面,查出所有部门显示 Collection&lt;Department&gt; depts = departmentDao.getDepartments(); model.addAttribute(\"depts\",depts); return \"emp/add\";&#125; 关键点：在添加部门页面要遍历部门信息，所以在方法中出入部门信息 3、添加功能完成新建一个PostMapping ThymeleafViewResolver 查看redirect和forward,原生的sendredirect方法； 1、新建一个postMapping的方法用来接受页面的添加POST请求 12345678910/** * 员工添加 */@PostMapping(value = \"/emp\")public String addEmp(Employee employee)&#123; employeeDao.save(employee); //来到员工列表页面、redirect:重定向到一个地址，forward转发到一个地址 return \"redirect:/emps\";&#125; 2、修改添加页面，添加name属性 123456789101112131415161718192021222324252627282930313233343536&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;!-- LastName --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"LastName\"&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"LastName\" name=\"lastName\" placeholder=\"LastName\"&gt; &lt;/div&gt; &lt;!-- Email --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"Email\"&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"Email\" name=\"email\" placeholder=\"zhangsan@163.com\"&gt; &lt;/div&gt; &lt;!--gender--&gt; &lt;div class=\"form-group\"&gt; &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\" &gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\" &gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- department --&gt; &lt;div class=\"form-group\"&gt; &lt;label &gt;department&lt;/label&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:each=\"dept:$&#123;depts&#125;\" th:value=\"$&#123;dept.id&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"birthDate\"&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"birthDate\" placeholder=\"2012-12-12\" name=\"birth\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添 加&lt;/button&gt;&lt;/form&gt; 1、部门对象问题？ 1&lt;select class=\"form-control\" name=\"department.id\"&gt; 2、日期格式化？ 属性中添加 date-formate 默认是 / 12345678910111213141516@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());&#125;@Overridepublic MessageCodesResolver getMessageCodesResolver() &#123; if (this.mvcProperties.getMessageCodesResolverFormat() != null) &#123; DefaultMessageCodesResolver resolver = new DefaultMessageCodesResolver(); resolver.setMessageCodeFormatter( this.mvcProperties.getMessageCodesResolverFormat()); return resolver; &#125; return null;&#125; 1spring.mvc.date-format=yyyy-MM-dd 8、员工编辑（改）思路使用add页面，并且数据回显，然后区分添加，PUT请求 1、修改按钮在list.html的编辑按钮加上链接 1234&lt;td&gt; &lt;a href=\"#\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-primary\"&gt;编辑&lt;/a&gt; &lt;button class=\"btn btn-sm btn-danger\"&gt;删除&lt;/button&gt;&lt;/td&gt; 2、编写跳转页面跳转到员工编辑页面的Controller 1234567891011/** * 员工编辑页面 */@GetMapping(value = \"/emp/&#123;id&#125;\")public String toEditPage(@PathVariable(\"id\") Integer id ,Model model)&#123; Employee emp = employeeDao.getEmpById(id); Collection&lt;Department&gt; departments = departmentDao.getDepartments(); model.addAttribute(\"emp\",emp); model.addAttribute(\"depts\",departments); return \"emp/add\";&#125; 3、对页面修改对add页面进行修改 1）、添加回显 2）、添加判断是否emp!=null（区分add or edit） 3）、添加put请求 –两个input的hidden标签 1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;!--发送put请求--&gt; &lt;!--1.SpringMVC配置HiddenHttpMethodFilter 2.页面创建一个post表单 3.创建一个 input name_method 值就是我们请求的方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"&gt; &lt;input type=\"hidden\" name=\"id\" th:value=\"$&#123;emp.id&#125;\" th:if=\"$&#123;emp!=null&#125;\"&gt; &lt;!-- LastName --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"LastName\"&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"LastName\" name=\"lastName\" placeholder=\"LastName\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;!-- Email --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"Email\"&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"Email\" name=\"email\" placeholder=\"zhangsan@163.com\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;!--gender--&gt; &lt;div class=\"form-group\"&gt; &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender&#125;==1\"&gt; &lt;label class=\"form-check-label\" &gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender&#125;==0\"&gt; &lt;label class=\"form-check-label\" &gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- department --&gt; &lt;div class=\"form-group\"&gt; &lt;label &gt;department&lt;/label&gt; &lt;select class=\"form-control\" name=\"department.id\" &gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:value=\"$&#123;dept.id&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"birthDate\"&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"birthDate\" placeholder=\"2012-12-12\" name=\"birth\" th:value=\"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添 加&lt;/button&gt; &lt;/form&gt;&lt;/main&gt; 9、员工删除（删）1、新建Contoller12345678/** * 员工删除 */@DeleteMapping(value = \"/emp/&#123;id&#125;\")public String deleteEmp(@PathVariable(\"id\") Integer id)&#123; employeeDao.deleteEmpById(id); return \"redirect:/emps\";&#125; 2、修改删除标签123&lt;button th:attr=\"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger deleteBtn\"&gt; 删除&lt;/button&gt; 3、写Form表单form表单卸载外面，input 中 name=”_method” value=”delete” 模拟delete请求 12345678 &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt; &lt;form id=\"deleteEmpForm\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"&gt; &lt;/form&gt;&lt;/div&gt; 4、写JS提交123456&lt;script&gt; $(\".deleteBtn\").click(function () &#123; $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; &#125;)&lt;/script&gt; return false;禁用btn提交效果 7、错误机制的处理1、默认的错误处理机制默认错误页面 原理参照 ErrorMvcAutoConfiguration:错误处理的自动配置 1org\\springframework\\boot\\spring-boot-autoconfigure\\1.5.12.RELEASE\\spring-boot-autoconfigure-1.5.12.RELEASE.jar!\\org\\springframework\\boot\\autoconfigure\\web\\ErrorMvcAutoConfiguration.class DefaultErrorAttributes 帮我们在页面共享信息 12345678910@Overridepublic Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes;&#125; BasicErrorController 1234567891011121314151617181920212223@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\")public class BasicErrorController extends AbstractErrorController &#123; //产生HTML数据 @RequestMapping(produces = \"text/html\") public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); &#125; //产生Json数据 @RequestMapping @ResponseBody public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ErrorPageCustomizer 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\";//系统出现错误以后来到error请求进行处理，(web.xml) DefaultErrorViewResolver 1234567891011121314151617181920212223@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125;private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以找到一个页面？error/状态码 String errorViewName = \"error/\" + viewName; //如果模板引擎可以解析地址，就返回模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //有模板引擎就返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //自己的文件 就在静态文件夹下找静态文件 /静态资源文件夹/404.html return resolveResource(errorViewName, model);&#125; 一旦系统出现4xx或者5xx错误 ErrorPageCustomizer就回来定制错误的响应规则,就会来到 /error请求,BasicErrorController处理，就是一个Controller 1.响应页面,去哪个页面是由 DefaultErrorViewResolver 拿到所有的错误视图 12345678910protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; l浏览器发送请求 accpt:text/html 客户端请求：accept:/* 2、如何定制错误响应​ 1）、如何定制错误的页面 ​ 1.有模板引擎：静态资源/404.html,什么错误什么页面；所有以4开头的 4xx.html 5开头的5xx.html ​ 有精确的404和4xx优先选择404 ​ 页面获得的数据 ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常信息 ​ errors:JSR303有关 ​ 2.没有放在模板引擎，放在静态文件夹，也可以显示，就是没法使用模板取值 ​ 3.没有放模板引擎，没放静态，会显示默认的错误 ​ 2）、如何定义错误的数据 举例子：新建4xx和5xx文件 1234567&lt;body &gt; &lt;p&gt;status: [[$&#123;status&#125;]]&lt;/p&gt; &lt;p&gt;timestamp: [[$&#123;timestamp&#125;]]&lt;/p&gt; &lt;p&gt;error: [[$&#123;error&#125;]]&lt;/p&gt; &lt;p&gt;message: [[$&#123;message&#125;]]&lt;/p&gt; &lt;p&gt;exception: [[$&#123;exception&#125;]]&lt;/p&gt;&lt;/body&gt; 3、如何定制Json数据1、仅发送json数据12345public class UserNotExitsException extends RuntimeException &#123; public UserNotExitsException()&#123; super(\"用户不存在\"); &#125;&#125; 123456789101112131415/** * 异常处理器 */@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExitsException.class) public Map&lt;String ,Object&gt; handlerException(Exception e)&#123; Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;(); map.put(\"code\", \"user not exist\"); map.put(\"message\", e.getMessage()); return map; &#125;&#125; 无法自适应 都是返回的json数据 2、转发到error自适应处理12345678910@ExceptionHandler(UserNotExitsException.class)public String handlerException(Exception e, HttpServletRequest request)&#123; Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;(); //传入自己的状态码 request.setAttribute(\"javax.servlet.error.status_code\", 432); map.put(\"code\", \"user not exist\"); map.put(\"message\", e.getMessage()); //转发到error return \"forward:/error\";&#125; 程序默认获取状态码 123456789101112protected HttpStatus getStatus(HttpServletRequest request) &#123; Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); if (statusCode == null) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; try &#123; return HttpStatus.valueOf(statusCode); &#125; catch (Exception ex) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; 没有自己写的自定义异常数据 3、自适应和定制数据传入Spring 默认的原理，出现错误后回来到error请求，会被BasicErrorController处理,响应出去的数据是由BasicErrorController的父类AbstractErrorController(ErrorController)规定的方法getAttributes得到的； 1、编写一个ErrorController的实现类【或者AbstractErrorController的子类】，放在容器中； 2、页面上能用的数据，或者是json数据返回能用的数据都是通过errorAttributes.getErrorAttributes得到； 容器中的DefaultErrorAtrributes.getErrorAtrributees();默认进行数据处理 12345678public class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\", \"wdjr\"); return map; &#125;&#125; 异常处理：把map方法请求域中 123456789101112 @ExceptionHandler(UserNotExitsException.class) public String handlerException(Exception e, HttpServletRequest request)&#123; Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;(); //传入自己的状态码 request.setAttribute(\"javax.servlet.error.status_code\", 432); map.put(\"code\", \"user not exist\"); map.put(\"message\", e.getMessage()); request.setAttribute(\"ext\", map); //转发到error return \"forward:/error\"; &#125;&#125; 在上面的MyErrorAttributes类中加上 123//我们的异常处理器Map&lt;String,Object&gt; ext = (Map&lt;String, Object&gt;) requestAttributes.getAttribute(\"ext\", 0);map.put(\"ext\", ext); 8、配置嵌入式servlet容器1、定制和修改Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器； 1、 修改Server相关的配置文件 application.properties 1234#通用的servlet容器配置server.xxx#tomcat的配置server.tomcat.xxxx 2、编写一个EmbeddedServletContainerCustomizer;嵌入式的Servlet容器的定制器；来修改Servlet的容器配置 12345678910@Beanpublic EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式Servlet的容器相关规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8999); &#125; &#125;;&#125; 其实同理，都是实现EmbeddedServletContainerCustomizer 2、注册Servlet三大组件三大组件 Servlet Filter Listener 由于SprringBoot默认是以jar包启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml 注册三大组件 ServletRegistrationBean12345@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet(),\"/servlet\"); return servletRegistrationBean;&#125; MyServlet 123456public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write(\"Hello Servlet\"); &#125;&#125; FilterRegistrationBean1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new MyFilter()); filterRegistrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return filterRegistrationBean;&#125; MyFilter 1234567891011121314151617public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"MyFilter process\"); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; &#125;&#125; ServletListenerRegistrationBean12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; MyListener 1234567891011public class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\".........web应用启动..........\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\".........web应用销毁..........\"); &#125;&#125; SpringBoot帮助我们自动配置SpringMVC的时候，自动注册SpringMVC的前端控制器；DispatcherServlet; 123456789101112131415161718@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截 /所有请求 包括静态资源 不包括jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration; &#125;&#125; 3、切换其他的Servlet容器在ServerProperties中 12345private final Tomcat tomcat = new Tomcat();private final Jetty jetty = new Jetty();private final Undertow undertow = new Undertow(); tomcat(默认支持) jetty（长连接） undertow（多并发） 切换容器 仅仅需要修改pom文件的依赖就可以 12345678910111213141516171819 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; 4、嵌入式Servlet容器自动配置原理12345678910111213141516@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//给容器导入组件 后置处理器 在Bean初始化前后执行前置后置的逻辑 创建完对象还没属性赋值进行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//当前是否引入tomcat依赖 //判断当前容器没有用户自定义EmbeddedServletContainerFactory，就会创建默认的嵌入式容器 @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 123456public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 继承关系 2）、EmbeddedServletContainer:(嵌入式的Servlet容器) 3）、TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; Tomcat tomcat = new Tomcat(); //配置tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的tomcat传入进去；并且启动tomcat容器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、嵌入式配置修改 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer:定制器帮我们修改了Servlet容器配置？ 怎么修改？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; if (this.beanFactory == null) &#123; return; &#125; registerSyntheticBeanIfMissing(registry, \"embeddedServletContainerCustomizerBeanPostProcessor\", EmbeddedServletContainerCustomizerBeanPostProcessor.class); registerSyntheticBeanIfMissing(registry, \"errorPageRegistrarBeanPostProcessor\", ErrorPageRegistrarBeanPostProcessor.class);&#125; 123456789101112131415161718192021222324252627282930313233@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每个定制器的customer方法给Servlet容器进行赋值 for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有的这个类型的组件：EmbeddedServletContainerCustomizer //定制Servlet,给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125; ServerProperties也是EmbeddedServletContainerCustomizer定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加响应的容器工厂 例：tomcat EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就要通过后置处理器； 1EmbeddedServletContainerCustomizerBeanPostProcessor 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取的所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 5、嵌入式Servlet容器启动原理什么时候创建嵌入式的Servlet的容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat; 获取嵌入式的容器工厂 1）、SpringBoot应用启动Run方法 2）、刷新IOC容器对象【创建IOC容器对象，并初始化容器，创建容器的每一个组件】；如果是web环境AnnotationConfigEmbeddedWebApplicationContext,如果不是AnnotationConfigApplicationContext 12345if (contextClass == null) &#123; try &#123; contextClass = Class.forName(this.webEnvironment ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS); &#125; 3）、refresh(context);刷新创建好的IOC容器 12345678910111213141516171819202122232425262728try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh();&#125; 4）、 onRefresh();web的ioc容器重写了onRefresh方法 5）、webioc会创建嵌入式的Servlet容器；createEmbeddedServletContainer 6）、获取嵌入式的Servlet容器工厂； 1EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); 从ioc容器中获取EmbeddedServletContainerFactory组件； 1234@Beanpublic TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123;return new TomcatEmbeddedServletContainerFactory();&#125; TomcatEmbeddedServletContainerFactory创建对象，后置处理器看这个对象，就来获取所有的定制器来定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，在将ioc容器中剩下的没有创建出的对象获取出来 ioc启动创建Servlet容器 9、使用外置的Servlet容器嵌入式的Servlet容器：应用达成jar包 ​ 优点：简单、便携 ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义定制器】，自己来编写嵌入式的容器工厂） 外置的Servlet容器：外面安装Tomcat是以war包的方式打包。 1、IDEA操作外部Servlet1、创建程序为war程序 2、选择版本 3、添加tomcat 4、选择tomcat 5、选择本地的Tomcat 6、配置tomcat路径 7、添加服务器 8、添加exploded的war配置，应用OK tomcat配置完成 二、配置webapp文件夹 1、点击配置 2、添加webapp目录 3、默认配置就可以 4、配置web.xml文件 5、文档目录结构 2、运行一个示例1、项目目录 2、配置文件写视图解析前后缀 123spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 3、HelloController 12345678@Controllerpublic class HelloController &#123; @GetMapping(\"/hello\") public String hello(Model model)&#123; model.addAttribute(\"message\",\"这是Controller传过来的message\"); return \"success\"; &#125;&#125; 4、success.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Success&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Success&lt;/h1&gt;message:$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 5、运行结果 步骤 1、必须创建一个war项目； 2、将嵌入式的Tomcat指定为provided 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3、必须编写一个SpringBootServletInitializer的子类，并调用configure方法里面的固定写法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot的主程序， return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4、启动服务器就可以； 3、原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet的容器； war包：启动服务器，服务器启动SpringBoot应用，【SpringBootServletInitializer】启动ioc容器 servlet3.0规范 8.2.4 共享库和运行时插件 规则： 1、服务器启动（web应用启动），会创建当前的web应用里面每一个jar包里面ServletContrainerInitializer的实现类的实例 2、SpringBootServletInitializer这个类的实现需要放在jar包下的META-INF/services文件夹下，有一个命名为javax.servlet.ServletContainerInitalizer的文件，内容就是ServletContainerInitializer的实现类全类名 3、还可以使用@HandlerTypes注解，在应用启动的时候可以启动我们感兴趣的类 流程： 1、启动Tomcat服务器 2、spring web模块里有这个文件 1org.springframework.web.SpringServletContainerInitializer 3、SpringServletContainerInitializer将handlerTypes标注的所有类型的类传入到onStartip方法的Set&lt;Class&lt;?&gt;&gt;;为这些感兴趣类创建实例 4、每个创建好的WebApplicationInitializer调用自己的onStratup 5、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6、SpringBootServletInitializer执行onStartup方法会创建createRootApplicationContext 12345678910111213141516171819202122232425262728293031protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) &#123; SpringApplicationBuilder builder = this.createSpringApplicationBuilder(); //环境构建器 StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, (ServletConfig)null); builder.environment(environment); builder.main(this.getClass()); ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null); builder.initializers(new ApplicationContextInitializer[]&#123;new ParentContextApplicationContextInitializer(parent)&#125;); &#125; builder.initializers(new ApplicationContextInitializer[]&#123;new ServletContextApplicationContextInitializer(servletContext)&#125;); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用Configure,子类重写了这个方法，将SpringBoot的主程序类传入进来 builder = this.configure(builder); //创建一个spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils.findAnnotation(this.getClass(), Configuration.class) != null) &#123; application.getSources().add(this.getClass()); &#125; Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation\"); if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //最后启动Spring容器 return this.run(application);&#125; 7、Spring的应用就启动完了并且创建IOC容器； 123456789101112131415161718192021222324252627282930313233public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; #","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"SpringBoot学习4：日志","date":"2018-11-06T11:59:41.000Z","path":"2018/11/06/SpringBoot学习4：日志/","text":"一、日志 Spring Boot2对日志有更改 1、日志框架小张：开发一个大型系统； 1、System.out.println(“”);将关键数据打印在控制台；去掉？卸载文件中 2、框架记录系统的一些运行信息；日志框架zhanglog.jar 3、高大上功能，异步模式？自动归档？xxx?zhanglog-good.jar? 4、将以前的框架卸下来？换上新的框架，重新修改之前的相关API;zhanglog-perfect.jar; 5、JDBC–数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar; ​ 给项目中导入具体的日志实现就行；我们之前的日志框架都是实现的抽象层； 市面上的日志框架 日志抽象层 日志实现 JCL(Jakarta Commons Logging) SLF4j(Simple Logging Facade for Java) jboss-logging Log4j JUL(java.util.logging) Log4j2 Logback 左边的抽象，右边的实现 SLF4J – Logback Spring Boot:底层是Spring框架，Spring默认框架是JCL； ​ SpringBoot选用SLF4J和logback 2、SLF4J使用1、如何在系统中使用SLF4j以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 应该给系统里面导入slf4j的jar包和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 每个日志框架的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架本身的配置文件； 2、遗留问题a系统(slf4j+logback)：Spring（commons-logging）、Hibernate（jboss-logging）、Mybatis 统一日志框架，即使是别的框架和我一起统一使用slf4j进行输出； 核心： 1、将系统中其他日志框架排除出去； 2、用中间包来替换原有的日志框架/ 3、导入slf4j的其他实现 3、SpingBoot日志框架解析打开IDEA ，打开pom文件的依赖图形化显示 SpringBoot的基础框架 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot的日志功能 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 总结： SpringBoot底层也是使用SLF4J+log4jback SpringBoot也把其他日志替换成了slf4j 起着commons.loggings的名字其实new的SLF4J替换中间包 SpringBoot2中改成了bridge 如果要引入其他框架？一定要把这个框架的日志依赖移除掉，而且底层 4、日志的使用1、默认配置trace-debug-info-warn-error 可以调整需要的日志级别进行输出，不用注释语句。 123456789101112131415//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //日志的级别 //从低到高 //可以调整输出的日志级别；日志就只会在这个级别以后的高级别生效 logger.trace(\"这是trace日志\"); logger.debug(\"这是debug信息\"); //SpringBoot默认给的是info级别，如果没指定就是默认的root级别 logger.info(\"这是info日志\"); logger.warn(\"这是warn信息\"); logger.error(\"这是Error信息\");&#125; 调整指定包的日志级别在配置文件中进行配置 1logging.level.com.wdjr=trace 日志输出格式 12345678#控制台输出的日志格式 #%d：日期#%thread：线程号 #%-5level：靠左 级别 #%logger&#123;50&#125;：全类名50字符限制,否则按照句号分割#%msg：消息+换行#%n：换行logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789logging.level.com.wdjr=trace#不指定path就是当前目录下生成springboot.log#logging.file=springboot.log#当前磁盘下根路径创建spring文件中log文件夹，使用spring.log作为默认logging.path=/spring/log#控制台输出的日志格式 日期 + 线程号 + 靠左 级别 +全类名50字符限制+消息+换行logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#指定文件中日志输出的格式logging.pattern.file=xxx 2、指定配置给类路径下放上每个日志框架自己的配置框架；SpringBoot就不会使用自己默认的配置 logging System Customization Logback logback-spring.xml ,logback-spring.groovy,logback.xml or logback.groovy Log4J2 log4j2-spring.xml or log4j2.xml JDK(Java Util Logging) logging.properties logback.xml直接被日志框架识别 ，logback-spring.xml日志框架就不直接加载日志配置项，由SpringBoot加载 123456&lt;springProfile name=\"dev\"&gt; &lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;&lt;/springProfile&gt;&lt;springProfile name!=\"dev\"&gt; &lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;&lt;/springProfile&gt; 如何调试开发环境,输入命令行参数 –spring.profiles.active=dev 如果不带后面的xx-spring.xml就会报错 3、切换日志框架可以根据slf4j的日志适配图，进行相关切换； 1、log4jslf4j+log4j的方式； 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 不推荐使用仅作为演示 2、log4j2切换为log4j2 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; #","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Slf4j","slug":"Slf4j","permalink":"http://yoursite.com/tags/Slf4j/"},{"name":"Log4j","slug":"Log4j","permalink":"http://yoursite.com/tags/Log4j/"},{"name":"Log4j2","slug":"Log4j2","permalink":"http://yoursite.com/tags/Log4j2/"}]},{"title":"SpringBoot学习3：配置文件","date":"2018-11-06T11:59:15.000Z","path":"2018/11/06/SpringBoot学习3：配置文件/","text":"一、配置文件1、配置文件Spring Boot使用全局配置文件，配置文件名是固定的； application.properties application.yml 配置文件作用：修改Spring Boot在底层封装好的默认值； YAML（YAML AIN’T Markup Language） 是一个标记语言 又不是一个标记语言 标记语言： 以前的配置文件；大多数使用的是 xxx.xml文件； 以数据为中心，比json、xml等更适合做配置文件 YAML：配置例子 12server: port: 9000 XML: 123&lt;server&gt; &lt;port&gt;9000&lt;/port&gt;&lt;/server&gt; 2、YAML语法1、基本语法k:(空格)v:表示一堆键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的 123server: port: 9000 path: /hello 属性和值也是大小写敏感 2、值的写法字面量：普通的值（数字，字符串，布尔） k: v:字面直接来写； 字符串默认不用加上单引号或者双引号 “”:双引号 不会转义字符串里的特殊字符；特殊字符会作为本身想要表示的意思 name:&quot;zhangsan\\n lisi&quot; 输出：zhangsan换行 lisi ‘’:单引号 会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name:&#39;zhangsan\\n lisi&#39; 输出：zhangsan\\n lisi 对象、Map（属性和值）键值对 k :v ：在下一行来写对象的属性和值的关系；注意空格控制缩进 对象还是k:v的方式 123frends: lastName: zhangsan age: 20 行内写法 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）:用-表示数组中的一个元素 1234pets: ‐ cat ‐ dog ‐ pig 行内写法 1pets: [cat,dog,pig] 组合变量 多个组合到一起 3、配置文件值注入1、@ConfigurationProperties1、application.yml 配置文件 123456789101112person: age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: wangwang age: 2 last-name: wanghuahua application.properties 配置文件（二选一） 12345678910idea配置文件utf-8properties 默认GBKperson.age=12person.boss=falseperson.last-name=张三person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=wanghuahuperson.dog.age=15 所以中文输出乱码，改进settings–&gt;file encoding –&gt;[property–&gt;utf-8 ,勾选转成ascii] javaBean 12345678910111213141516/*** 将配置文件的配置每个属性的值，映射到组件中* @ConfigurationProperties:告诉SpringBoot将文本的所有属性和配置文件中的相关配置进行绑定；* prefix = \"person\" 配置文件爱你的那个属性进行一一映射* *只有这个组件是容器中的组件，才能提供到容器中*/@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 导入配置文件处理器，以后编写配置就有提示了 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐configuration‐processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2、@Value注解更改javaBean中的注解 12345678910111213@Componentpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;\"&gt;&lt;/property&gt; * &lt;/bean&gt; */ @Value(\"$&#123;person.last-name&#125;\") private String lastName; @Value(\"#&#123;11*2&#125;\") private Integer age; @Value(\"true\") private Boolean boss; @ConfigurationProperties @Value 功能 批量注入配置文件属性 单个指定 松散绑定(语法) 支持 不支持 spEL 不支持 支持 JSR303校验 支持 不支持 复杂类型 支持 不支持 松散语法：javaBean中last-name(或者lastName) –&gt;application.properties中的last-name; spEL语法：#{11*2} JSR303：@Value会直接忽略，校验规则 JSR303校验： 123456@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; @Email private String lastName; 复杂类型栗子： 123456789101112@Componentpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;\"&gt;&lt;/property&gt; * &lt;/bean&gt; */ private String lastName; private Integer age; private Boolean boss; // @Value(\"$&#123;person.maps&#125;\") private Map&lt;String,Object&gt; maps; 以上会报错，不支持复杂类型 使用场景分析 ​ 如果说，我们只是在某个业务逻辑中获取一下配置文件的某一项值，使用@Value； 如果专门编写了一个javaBean和配置文件进行映射，我们直接使用@ConfigurationProperties 举栗子： 1、编写新的Controller文件 12345678910@RestControllerpublic class HelloController &#123; @Value(\"$&#123;person.last-name&#125;\") private String name; @RequestMapping(\"/hello\") public String sayHello()&#123; return \"Hello\"+ name; &#125;&#125; 2、配置文件 12345678person.age=12person.boss=falseperson.last-name=李四person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=wanghuahuperson.dog.age=15 3、测试运行 访问 localhost:9000/hello 结果为Hello 李四 3、其他注解 @PropertySource 作用：加载指定的properties配置文件 1、新建一个person.properties文件 12345678person.age=12person.boss=falseperson.last-name=李四person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=wanghuahuperson.dog.age=15 2、在javaBean中加入@PropertySource注解 12345@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; @ImportResource 作用：导入Spring配置文件，并且让这个配置文件生效 1、新建一个Spring的配置文件，bean.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"HelloService\" class=\"com.wdjr.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; 2、编写测试类，检查容器是否加载Spring配置文件写的bean 12345678@AutowiredApplicationContext ioc;@Testpublic void testHelloService()&#123; boolean b = ioc.containsBean(\"HelloService\"); System.out.println(b);&#125; import org.springframework.context.ApplicationContext; 3、运行检测 结果为false，没有加载配置的内容 4、使用@ImportResource注解 将@ImportResource标注在主配置类上 12345678@ImportResource(locations=&#123;\"classpath:beans.xml\"&#125;)@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02ConfigApplication.class, args); &#125;&#125; 5、再次运行检测 结果为true 缺点：每次指定xml文件太麻烦 SpringBoot推荐给容器添加组件的方式： 1、配置类=====Spring的xml配置文件（old） 2、全注解方式@Configuration+@Bean（new） 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来代替之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件 */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器这个组件id就是方法名 @Bean public HelloService helloService01()&#123; System.out.println(\"配置类给容器添加了HelloService组件\"); return new HelloService(); &#125;&#125; 12345678@AutowiredApplicationContext ioc;@Testpublic void testHelloService()&#123; boolean b = ioc.containsBean(\"helloService01\"); System.out.println(b);&#125; 容器这个组件id就是方法名 4、配置文件占位符1、随机数12$&#123;random.value&#125; 、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[100,200]&#125; 2、获取配置值12345678person.age=$&#123;random.int&#125;person.boss=falseperson.last-name=张三$&#123;random.uuid&#125;person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.last-name&#125;&apos;s wanghuahuperson.dog.age=15 存在以下两种情况 没有声明person.last-name会报错，新声明的需要加默认值 12345678person.age=$&#123;random.int&#125;person.boss=falseperson.last-name=张三$&#123;random.uuid&#125;person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;&apos;s wanghuahuperson.dog.age=15 结果：输出hello&#39;s wanghuahua 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml application.properties application-dev.properties application-prod.properties 默认使用application.properties application.properties配置文件指定 1spring.profiles.active=dev 2、YAML文档块123456789101112131415161718server: port: 8081spring: profiles: active: dev---server: port: 9000spring: profiles: dev---server: port: 80spring: profiles: prod 3、激活指定profile1、在配置文件中激活 2、命令行： –spring.profiles.active=dev 优先级大于配置文件 打包 成jar后 java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev 虚拟机参数 -Dspring.profiles.active=dev 6、加载配置文件位置SpringBoot启动扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 file:./config/ file./ classpath:/config/ classpath:/ 优先级从高到低顺序，高优先级会覆盖低优先级的相同配置；互补配置 也可以通过spring.config.location来改变默认配置 123&gt; server.servlet.context-path=/boot03&gt; &gt; 注：spring boot1x 是server.context.path=/boot02 还可以通过spring.config.location来改变配置文件的位置 项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的配置文件会共同起作用，互补配置 java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=E:/work/application.properties 运维比较有用，从外部加载，不用修改别的文件 7.引入外部配置SpringBoot也可以从以下位置加载配置；优先级从高到低；高优先级覆盖低优先级，可以互补 命令行参数 java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar –server.port=9005 –server.context-path=/abc 中间一个空格 来自java:comp/env的JNDI属性 java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 ​ 优先加载profile, 由jar包外到jar包内 jar包外部的application-{profile}.properties或application.yml(带Spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带Spring.profile)配置文件 jar包外部的application.properties或application.yml(带Spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 ​ @Configuration注解类的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 官方文档 8、自动配置配置文件到底怎么写？ Spring的所有配置参数 自动配置原理很关键 1、自动配置原理1）、SpringBoot启动的时候加载主配置类，开启自动配置功能，@EnableAutoConfiguration 2）、@EnableAutoConfiguration 作用： 利用AutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容 获取候选的配置 1List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 扫描类路径下的 1234SpringFactoriesLoader.loadFactoryNames(）扫描所有jar包类路径下的 MATA-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加到容器中 将类路径下 MATE-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到了容器中； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration 为例 1234567891011121314151617181920212223242526272829@Configuration //表示是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;)//启动指定类的Configurationproperties功能；将配置文件中的值和HttpEncodingProperties绑定起来了；并把HttpEncodingProperties加入ioc容器中@ConditionalOnWebApplication//根据不同的条件，进行判断，如果满足条件，整个配置类里面的配置就会失效，判断是否为web应用；( type = Type.SERVLET)@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断当前项目有没有这个类，解决乱码的过滤器@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true)//判断配置文件是否存在某个配置 spring.http.encoding，matchIfMissing = true如果不存在也是成立，即使不配置也生效public class HttpEncodingAutoConfiguration &#123; //给容器添加组件，这个组件的值需要从properties属性中获取 private final HttpEncodingProperties properties; //只有一个有参数构造器情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE)); return filter; &#125; 5）、所有在配置文件中能配置的属性都是在xxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 12@ConfigurationProperties(prefix = \"spring.http.encoding\")//从配置文件中的值进行绑定和bean属性进行绑定public class HttpEncodingProperties &#123; 根据当前不同条件判断，决定这个配置类是否生效？ 一旦这个配置类生效；这个配置类会给容器添加各种组件；这些组件的属性是从对应的properties中获取的，这些类里面的每个属性又是和配置文件绑定的 2、所有的自动配置组件每一个xxxAutoConfiguration这样的类都是容器中的一个组件，都加入到容器中； 作用：用他们做自动配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 3、精髓：1）、SpringBoot启动会加载大量的自动配置类 2）、我们看我们需要的功能有没有SpringBoot默认写好的默认配置类； 3）、如果有在看这个自动配置类中配置了哪些组件；（只要我们要用的组件有，我们需要再来配置） 4）、给容器中自动配置添加组件的时候，会从properties类中获取属性。我们就可以在配置文件中指定这些属性的值 xxxAutoConfiguration:自动配置类； 给容器中添加组件 xxxProperties:封装配置文件中的属性； 跟之前的Person类一样，配置文件中值加入bean中 4、细节1、@Conditional派生注解 利用Spring注解版原生的@Conditional作用 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional派生注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissBean 容器中不存在指定Bean @ConditionalOnExpression 满足spEL表达式 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean,或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定的资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 2、自动配置报告自动配置类必须在一定条件下生效 我们可以通过启用debug=true属性，配置文件，打印自动配合报告，这样就可以知道自动配置类生效 1debug=true 自动配置报告 1234567891011121314151617181920============================CONDITIONS EVALUATION REPORT============================Positive matches:（启动的，匹配成功的）----------------- CodecsAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.http.codec.CodecConfigurer'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) ...... Negative matches:（没有启动的，没有匹配成功的）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)..... #","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Yaml","slug":"Yaml","permalink":"http://yoursite.com/tags/Yaml/"}]},{"title":"SpringBoot学习2：Hello World","date":"2018-11-06T11:58:37.000Z","path":"2018/11/06/SpringBoot学习2：Hello-World/","text":"一，Spring Boot的Hello World1、创建一个Maven工程2、导入Spring Boot的相关依赖12345678910111213141516171819202122232425&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写个主程序1234567@SpringBootApplicationpublic class SpringBoot01HelloQuickApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot01HelloQuickApplication.class, args); &#125;&#125; 4、编写相应的Controller和Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"hello world\"; &#125;&#125; 5、运行主程序测试访问 localhost:8080/hello 6、简化部署在pom.xml文件中，导入build插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 二、HelloWorld深度理解1.POM.xml文件1、父项目123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 这个父项目spring-boot-starter-parent又依赖一个父项目 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 下面有个属性，定义了对应的版本号 1234567891011&lt;properties&gt; &lt;activemq.version&gt;5.15.3&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.63&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.4.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.9.1&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;build-helper-maven-plugin.version&gt;3.0.0&lt;/build-helper-maven-plugin.version&gt; 。。。。。。。 Spring Boot的版本仲裁中心 会自动导入对应的版本，不需要我们自己导入依赖，没有dependencies里面管理的依赖自己声明 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web:帮我们导入web模块正常运行所依赖的组件 spring boot将所有的功能场景都抽取出来，做成一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会被导入进来，要用什么功能就导入什么场景的启动器。 2、主程序入口1234567@SpringBootApplicationpublic class SpringBoot01HelloQuickApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot01HelloQuickApplication.class, args); &#125;&#125; @SpringBootApplication: 说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动应用 进入SpringBootApplication注解 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration：SpringBoot的配置类： 标准在某个类上，表示这是一个SpringBoot的配置类 @Configuration:配置类上，来标注这个注解；配置类 —- 配置文件，也是容器中的一个组件（@Component）@EnableAutoConfiguration:开启自动配置功能以前需要自动配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效。 123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage:自动配置包@Import({Registrar.class})：底层注解，给容器导入组件；将主配置类（@SpringBootApplication标注的类）的所在包及下面所有的子包里面的所有组件扫描到Spring容器； @Import({AutoConfigurationImportSelector.class})：给容器导入组件？ AutoConfigurationImportSelector：导入组件选择器 将所有需要导入的组件以及全类名的方式返回；这些组件将以字符串数组 String[] 添加到容器中； 会给容器非常多的自动配置类，（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件。 12345678protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations =SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META‐INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations;&#125; SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),this.getBeanClassLoader()); Spring Boot在启动的时候从类路径下的META-INF/spring.factorys中获取的EnableAutoConfiguration指定的值； 将这些值作为自动配置类导入到容器中，自动配置就生效了。 J2EE的整体解决方案 org\\springframework\\boot\\spring-boot-autoconfigure\\2.0.1.RELEASE\\spring-boot-autoconfigure-2.0.1.RELEASE.jar 三、使用Spring Initializer创建一个快速向导1.IDE支持使用Spring Initializer 自己选择需要的组件:例如web 默认生成的SpringBoot项目 主程序已经生成好了，我们只需要完成我们的逻辑 resources文件夹目录结构 static:保存所有的静态文件；js css images templates:保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat,默认不支持JSP）；可 以使用模板引擎（freemarker.thymeleaf）; application.properties:Spring Boot的默认配置，例如 server.port=9000","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot学习1：入门及配置","date":"2018-11-06T11:28:01.000Z","path":"2018/11/06/SpringBoot学习1：入门及配置/","text":"一、Spring Boot入门1、Spring Boot简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 2、微服务微服务：架构风格（服务微化） 一个应用应该是一组小型服务，可以通过HTTP的方式进行互通 单体应用：ALL IN ONE 微服务：每个功能元素最终都是一个可以独立替换和升级的软件单元 3、环境准备环境约束 jdk1.8 maven 3.x :maven3.3以上 IDEA2017 SpringBoot 1.5.9RELEASE 1、MAVEN设置12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 配置JDK版本 --&gt;&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- 当 nexus-aliyun 下不了的包，或许这个镜像能下， 才开放它，这个实在太慢，而且要把它放在首位，即 nexus-aliyun 之前，做过测试。 所以它的用途只有那么一瞬间，就是或许它能下载，可以通过 url 去查找确定一下 --&gt; &lt;!-- &lt;mirror&gt; &lt;id&gt;spring-libs-milestone&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;http://repo.spring.io/libs-milestone&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- nexus-aliyun 首选，放第一位,有不能下载的包，再去做其他镜像的选择 --&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 备选镜像，也是可以通过 url 去查找确定一下， 该镜像是否含有你想要的包，它比 spring-libs-milestone 快 --&gt; &lt;mirror&gt; &lt;id&gt;central-repository&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; typor&lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://central.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; 2、IDEA设置​ 配置IDEA的Maven，指定Setting的Maven目录和MAVEN的setting.xml文件 ​ 快捷键： ​ Ctrl+D 复制一行 ​ Ctrl+Y 删除一行 ​ Ctrl+P 参数提示 ​ Ctrl+Alt+V 自动补齐方法 ​ Ctrl+N 查找类方法 ​ Alt+Ins 构造器、getter/setter toString ​ Ctrl+O 重载方法提示 ​ Alt+Enter 提示导入类etc ​ Shift+F6 :文件重命名 4、Spring Boot的Hello World1、创建一个Maven工程2、导入Spring Boot的相关依赖12345678910111213141516171819202122232425&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写个主程序1234567@SpringBootApplicationpublic class SpringBoot01HelloQuickApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot01HelloQuickApplication.class, args); &#125;&#125; 4、编写相应的Controller和Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"hello world\"; &#125;&#125; 5、运行主程序测试访问 localhost:8080/hello 6、简化部署在pom.xml文件中，导入build插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 5. 参考资料尚硅谷SpringBoot","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Java基础1:面向对象","date":"2018-11-06T04:11:05.337Z","path":"2018/11/06/Java基础1：面向对象/","text":"面向对象四大特性1. 抽象将一类对象的共同特征提取出来构建的类。包括数据抽象和行为抽象。抽象只关注对象有哪些行为和属性，而不关注具体的细节。 2. 封装利用抽象数据类型将对象的属性和对属性的操作封装起来，使之成为一个整体。数据被保护起来，对外保留必要的接口。用户无需知道具体的细节，可以通过对象对外提供的接口来访问数据。 2.1 优点减少耦合：可以独立地开发、测试、优化、使用、理解和修改减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块 有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的 如下代码，用户不需要知道name,gender,age属性的具体细节，只能通过相应的public接口实现具体的业务，保护了代码的完整性和安全性。 12345678910111213141516171819202122 public class Person &#123; private String name; private int gender; private int age; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender == 0 ? \"man\" : \"woman\"; &#125; public void work() &#123; if (18 &lt;= age &amp;&amp; age &lt;= 50) &#123; System.out.println(name + \" is working very hard!\"); &#125; else &#123; System.out.println(name + \" can't work any more!\"); &#125; &#125;&#125; 3. 继承继承是从已有的类中得到（派生出）继承信息产生新类的过程（is-a）。在设计模式中，继承应当遵循里氏替换原则，即子类对象必须能够替换所有父类对象。 4. 多态不同子类型的对象对同一消息做出不同的响应。包括运行时多态和编译时多态。 运行时多态指方法的重写（程序中对象指向的具体类型要等到运行时才能够确定）。 编译时多态指方法的重载。 运行时多态的条件： 继承关系 重写方法 向上转型 123456789101112131415161718192021222324252627282930313233343536373839public class Instrument &#123; public void play() &#123; System.out.println(\"Instument is playing...\"); &#125;&#125;//继承public class Wind extends Instrument &#123;//重写父类的方法 public void play() &#123; System.out.println(\"Wind is playing...\"); &#125;&#125;//继承public class Percussion extends Instrument &#123;//重写父类的方法 public void play() &#123; System.out.println(\"Percussion is playing...\"); &#125;&#125;public class Music &#123; public static void main(String[] args) &#123; List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;(); //加入Wind对象 instruments.add(new Wind()); //加入Percussion对象 instruments.add(new Percussion()); for(Instrument instrument : instruments) &#123; //运行时多态 instrument.play(); &#125; &#125;&#125; 5. Q:面向对象和面向过程的区别？用面向过程可以实现面向对象吗？ 面向对象和面向过程的区别 面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是个家用电器，你只需要知道他的功能，不需要知道它的工作原理。​ - 面向过程是一种是“事件”为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想。​ - 简单的举个例子：汽车发动、汽车到站 这对于 面向过程 来说，是两个事件，汽车启动是一个事件，汽车到站是另一个事件，面向过程编程的过程中我们关心的是事件，而不是汽车本身。针对上述两个事件，形成两个函数，之 后依次调用。（事件驱动，动词为主） 然而这对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为的顺序没有强制要求。（对象驱动，名词为主，将问题抽象出具体的对象，而这个对象有自己的属性和方法，在解决问题的时候是将不同的对象组合在一起使用） 用面向过程可以实现面向对象吗 ？ 如果是 C 语言来展现出面向对象的思想，C 语言中是不是有个叫结构体的东西，这个里面有自己定义的变量 可以通过函数指针就可以实现对象 6. Q:面向对象开发的六个基本原则 单一原则：一个类应该仅有一个引起它变化的原因。 里氏替换原则：任何时候子类型能够替换掉它们的父类型。 开闭原则：软件实体应当对扩展开放，对修改关闭。 依赖倒置原则：要依赖于抽象，不要依赖于具体类。 接口隔离：不应该强迫客户依赖于他们不用的方法 。 最少知道原则（迪米特法则）：只和你的朋友谈话。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础3:String类型","date":"2018-11-05T16:22:31.000Z","path":"2018/11/06/Java基础3：String类型/","text":"String（java.lang.String）1. 不可变性 public final class String{xxx….} 以final修饰，表示String类不可被继承 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 内部为一个char数组，也被初始化为final，一旦被初始化后就不可变。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 2. String的连接12345678910111213@Test public void contact () &#123; //1连接方式 String s1 = \"a\"; String s2 = \"a\"; String s3 = \"a\" + s2; String s4 = \"a\" + \"a\"; String s5 = s1 + s2; //表达式只有常量时，编译期完成计算 //表达式有变量时，运行期才计算，所以地址不一样 System.out.println(s3 == s4); //f System.out.println(s3 == s5); //f System.out.println(s4 == \"aa\"); //t &#125; 3. String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String(\"aaa\");String s2 = new String(\"aaa\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true 4. String类型的intern12345678910public void intern () &#123; //2：string的intern使用 //s1是基本类型，比较值。s2是string实例，比较实例地址 //字符串类型用equals方法比较时只会比较值 String s1 = \"a\"; String s2 = new String(\"a\"); //调用intern时,如果s2中的字符不在常量池，则加入常量池并返回常量的引用 String s3 = s2.intern(); System.out.println(s1 == s2); System.out.println(s1 == s3); &#125; 5. String类型的equals12345678910111213141516171819202122//重写Object的equals方法public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 6. String,StringBuffer,StringBuilder，以及对String不变性的理解6.1 String、StringBuffer、StringBuilder 都是 final 类，都不允许被继承 String 长度是不可变的，StringBuffer、StringBuilder 长度是可变的 StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer 在 StringBuilder 的方法之上添加了 synchronized 修饰，保证线程安全 StringBuilder 比 StringBuffer 拥有更好的性能 如果一个 String 类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时 String 的速度比 StringBuffer 和 StringBuilder 的性能好的多 6.2 String 不变性的理解 String 类是被 final 进行修饰的，不能被继承 在用 + 号链接字符串的时候会创建新的字符串 String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有 “Hello world” 字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有 “Hello world” 对象，则堆上和静态区中都需要创建对象。 在 Java 中, 通过使用 “+” 符号来串联字符串的时候,，实际上底层会转成通过 StringBuilder 实例的 append() 方法来实现。 6.3 StringBuilder,StringBuffer底层6.4 append123456789101112131415161718192021222324252627282930313233343536/** * The value is used for character storage. */ char[] value; //初始化容量为16 /** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. */ public StringBuilder() &#123; super(16); &#125; //这两个类的append方法都是来自父类AbstractStringBuilder的方法 public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; &#125; @Override public StringBuilder append(String str) &#123; super.append(str); return this; &#125; @Override public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; 6.5 扩容12345678910111213141516171819202122232425//注意在append方法中调用到了一个函数 //ensureCapacityInternal(count +len); //该方法是计算append之后的空间是否足够，不足的话需要进行扩容 public void ensureCapacity(int minimumCapacity) &#123; if (minimumCapacity &gt; 0) ensureCapacityInternal(minimumCapacity); &#125; private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125; &#125; //如果新字符串长度大于value数组长度则进行扩容 扩容后的长度一般为原来的两倍 + 2； //假如扩容后的长度超过了jvm支持的最大数组长度MAX_ARRAY_SIZE。 //考虑两种情况 如果新的字符串长度超过int最大值，则抛出异常，否则直接使用数组最大长度作为新数组的长度。 private int hugeCapacity(int minCapacity) &#123; if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow throw new OutOfMemoryError(); &#125; return (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE; &#125; 6.6 删除123456789101112131415//这两个类型的删除操作：都是调用父类的delete方法进行删除 public AbstractStringBuilder delete(int start, int end) &#123; if (start &lt; 0) throw new StringIndexOutOfBoundsException(start); if (end &gt; count) end = count; if (start &gt; end) throw new StringIndexOutOfBoundsException(); int len = end - start; if (len &gt; 0) &#123; System.arraycopy(value, start + len, value, start, count - end); count -= len; &#125; return this; &#125; //事实上是将剩余的字符重新拷贝到字符数组value。 用到了system.arraycopy来拷贝数组，速度是比较快的","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础2:基本数据类型","date":"2018-11-05T16:21:04.000Z","path":"2018/11/06/Java基础2：基本数据类型/","text":"8种基本数据类型1. 基本数据类型的大小 byte(-2^7^ ~ 2^7^-1) 1个字节 8位 –&gt; Byte(包装类) short(-2^15^ ~ 2^15^-1) 2个字节 16位 –&gt; Short int(-2^31^ ~ 2^31^-1) 4个字节 32位 –&gt; Integer long(-2^63^ ~ 2^63^-1) 8个字节 64位 –&gt; Long char 2个字节 16位 –&gt;Character float 4个字节 32位 –&gt;Float double 8个字节 64位 –&gt;Double boolean 未定 –&gt;Boolean 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 2. ValueOf缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 3. 源码123456//valueOf源码public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F 因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]
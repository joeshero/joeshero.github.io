[{"title":"Java基础3:String类型","date":"2018-11-05T16:22:31.000Z","path":"2018/11/06/Java基础3：String类型/","text":"String（java.lang.String）不可变性 public final class String{xxx….} 以final修饰，表示String类不可被继承 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 内部为一个char数组，也被初始化为final，一旦被初始化后就不可变。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String的连接12345678910111213@Test public void contact () &#123; //1连接方式 String s1 = \"a\"; String s2 = \"a\"; String s3 = \"a\" + s2; String s4 = \"a\" + \"a\"; String s5 = s1 + s2; //表达式只有常量时，编译期完成计算 //表达式有变量时，运行期才计算，所以地址不一样 System.out.println(s3 == s4); //f System.out.println(s3 == s5); //f System.out.println(s4 == \"aa\"); //t &#125; String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String(\"aaa\");String s2 = new String(\"aaa\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true String类型的intern12345678910public void intern () &#123; //2：string的intern使用 //s1是基本类型，比较值。s2是string实例，比较实例地址 //字符串类型用equals方法比较时只会比较值 String s1 = \"a\"; String s2 = new String(\"a\"); //调用intern时,如果s2中的字符不在常量池，则加入常量池并返回常量的引用 String s3 = s2.intern(); System.out.println(s1 == s2); System.out.println(s1 == s3); &#125; String类型的equals12345678910111213141516171819202122//重写Object的equals方法public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; String,StringBuffer,StringBuilder，以及对String不变性的理解 String、StringBuffer、StringBuilder 都是 final 类，都不允许被继承 String 长度是不可变的，StringBuffer、StringBuilder 长度是可变的 StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer 在 StringBuilder 的方法之上添加了 synchronized 修饰，保证线程安全 StringBuilder 比 StringBuffer 拥有更好的性能 如果一个 String 类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时 String 的速度比 StringBuffer 和 StringBuilder 的性能好的多 String 不变性的理解 String 类是被 final 进行修饰的，不能被继承 在用 + 号链接字符串的时候会创建新的字符串 String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有 “Hello world” 字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有 “Hello world” 对象，则堆上和静态区中都需要创建对象。 在 Java 中, 通过使用 “+” 符号来串联字符串的时候,，实际上底层会转成通过 StringBuilder 实例的 append() 方法来实现。 StringBuilder,StringBuffer底层append123456789101112131415161718192021222324252627282930313233343536/** * The value is used for character storage. */ char[] value; //初始化容量为16 /** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. */ public StringBuilder() &#123; super(16); &#125; //这两个类的append方法都是来自父类AbstractStringBuilder的方法 public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; &#125; @Override public StringBuilder append(String str) &#123; super.append(str); return this; &#125; @Override public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; 扩容12345678910111213141516171819202122232425//注意在append方法中调用到了一个函数 //ensureCapacityInternal(count +len); //该方法是计算append之后的空间是否足够，不足的话需要进行扩容 public void ensureCapacity(int minimumCapacity) &#123; if (minimumCapacity &gt; 0) ensureCapacityInternal(minimumCapacity); &#125; private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125; &#125; //如果新字符串长度大于value数组长度则进行扩容 扩容后的长度一般为原来的两倍 + 2； //假如扩容后的长度超过了jvm支持的最大数组长度MAX_ARRAY_SIZE。 //考虑两种情况 如果新的字符串长度超过int最大值，则抛出异常，否则直接使用数组最大长度作为新数组的长度。 private int hugeCapacity(int minCapacity) &#123; if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow throw new OutOfMemoryError(); &#125; return (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE; &#125; 删除123456789101112131415//这两个类型的删除操作：都是调用父类的delete方法进行删除 public AbstractStringBuilder delete(int start, int end) &#123; if (start &lt; 0) throw new StringIndexOutOfBoundsException(start); if (end &gt; count) end = count; if (start &gt; end) throw new StringIndexOutOfBoundsException(); int len = end - start; if (len &gt; 0) &#123; System.arraycopy(value, start + len, value, start, count - end); count -= len; &#125; return this; &#125; //事实上是将剩余的字符重新拷贝到字符数组value。 用到了system.arraycopy来拷贝数组，速度是比较快的","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"Java基础2:基本数据类型","date":"2018-11-05T16:21:04.000Z","path":"2018/11/06/Java基础2：基本数据类型/","text":"8种基本数据类型基本数据类型的大小 byte(-2^7^ ~ 2^7^-1) 1个字节 8位 –&gt; Byte(包装类) short(-2^15^ ~ 2^15^-1) 2个字节 16位 –&gt; Short int(-2^31^ ~ 2^31^-1) 4个字节 32位 –&gt; Integer long(-2^63^ ~ 2^63^-1) 8个字节 64位 –&gt; Long char 2个字节 16位 –&gt;Character float 4个字节 32位 –&gt;Float double 8个字节 64位 –&gt;Double boolean 1位 –&gt;Boolean 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 ValueOf缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 123456//valueOf源码public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F 因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"Java基础1:面向对象","date":"2018-11-05T15:41:28.000Z","path":"2018/11/05/java基础1：面向对象/","text":"面向对象四大特性 抽象（有时候会省略） 封装 继承 多态 抽象 将一类对象的共同特征提取出来构建的类。包括数据抽象和行为抽 象。抽象只关注对象有哪些行为和属性，而不关注具体的细节。 封装 利用抽象数据类型将对象的属性和对属性的操作封装起来，使之成为 一个整体。数据被保护起来，对外保留必要的接口。用户无需知道具体的细节，可以通过对象对外提供的接口来访问数据。 优点 减少耦合：可以独立地开发、测试、优化、使用、理解和修改减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块 有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的 如下代码，用户不需要知道name,gender,age属性的具体细节，只能通过相应的public接口实现具体的业务，保护了代码的完整性和安全性。 12345678910111213141516171819202122public class Person &#123; private String name; private int gender; private int age; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender == 0 ? \"man\" : \"woman\"; &#125; public void work() &#123; if (18 &lt;= age &amp;&amp; age &lt;= 50) &#123; System.out.println(name + \" is working very hard!\"); &#125; else &#123; System.out.println(name + \" can't work any more!\"); &#125; &#125;&#125; 继承继承是从已有的类中得到（派生出）继承信息产生新类的过程（is-a）。在设计模式中，继承应当遵循里氏替换原则，即子类对象必须能够替换所有父类对象。 多态不同子类型的对象对同一消息做出不同的响应。包括运行时多态和编译时多态。 运行时多态指方法的重写（程序中对象指向的具体类型要等到运行时才能够确定）。 编译时多态指方法的重载。 运行时多态的条件： 继承关系 重写方法 向上转型 123456789101112131415161718192021222324252627282930313233343536373839public class Instrument &#123; public void play() &#123; System.out.println(\"Instument is playing...\"); &#125;&#125;//继承public class Wind extends Instrument &#123;//重写父类的方法 public void play() &#123; System.out.println(\"Wind is playing...\"); &#125;&#125;//继承public class Percussion extends Instrument &#123;//重写父类的方法 public void play() &#123; System.out.println(\"Percussion is playing...\"); &#125;&#125;public class Music &#123; public static void main(String[] args) &#123; List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;(); //加入Wind对象 instruments.add(new Wind()); //加入Percussion对象 instruments.add(new Percussion()); for(Instrument instrument : instruments) &#123; //运行时多态 instrument.play(); &#125; &#125;&#125; Q:面向对象和面向过程的区别？用面向过程可以实现面向对象吗？ 面向对象和面向过程的区别 面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是个家用电器，你只需要知道他的功能，不需要知道它的工作原理。 面向过程是一种是“事件”为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想。 简单的举个例子：汽车发动、汽车到站 这对于 面向过程 来说，是两个事件，汽车启动是一个事件，汽车到站是另一个事件，面向过程编程的过程中我们关心的是事件，而不是汽车本身。针对上述两个事件，形成两个函数，之 后依次调用。（事件驱动，动词为主） 然而这对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为的顺序没有强制要求。（对象驱动，名词为主，将问题抽象出具体的对象，而这个对象有自己的属性和方法，在解决问题的时候是将不同的对象组合在一起使用） 用面向过程可以实现面向对象吗 ？ 如果是 C 语言来展现出面向对象的思想，C 语言中是不是有个叫结构体的东西，这个里面有自己定义的变量 可以通过函数指针就可以实现对象 Q:面向对象开发的六个基本原则 单一原则：一个类应该仅有一个引起它变化的原因。 里氏替换原则：任何时候子类型能够替换掉它们的父类型。 开闭原则：软件实体应当对扩展开放，对修改关闭。 依赖倒置原则：要依赖于抽象，不要依赖于具体类。 接口隔离：不应该强迫客户依赖于他们不用的方法 。 最少知道原则（迪米特法则）：只和你的朋友谈话。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]}]